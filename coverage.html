
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dyaksa/warehouse/api/controller/auth_controller.go (0.0%)</option>
				
				<option value="file1">github.com/dyaksa/warehouse/api/controller/order_controller.go (0.0%)</option>
				
				<option value="file2">github.com/dyaksa/warehouse/api/controller/product_controller.go (0.0%)</option>
				
				<option value="file3">github.com/dyaksa/warehouse/api/controller/shop_controller.go (0.0%)</option>
				
				<option value="file4">github.com/dyaksa/warehouse/api/controller/stock_release_controller.go (0.0%)</option>
				
				<option value="file5">github.com/dyaksa/warehouse/api/controller/warehouse_controller.go (0.0%)</option>
				
				<option value="file6">github.com/dyaksa/warehouse/api/controller/warehouse_transfer_controller.go (0.0%)</option>
				
				<option value="file7">github.com/dyaksa/warehouse/api/middleware/jwt_auth_middleware.go (0.0%)</option>
				
				<option value="file8">github.com/dyaksa/warehouse/api/middleware/ratelimit_middleware.go (0.0%)</option>
				
				<option value="file9">github.com/dyaksa/warehouse/api/route/auth_route.go (0.0%)</option>
				
				<option value="file10">github.com/dyaksa/warehouse/api/route/order_route.go (0.0%)</option>
				
				<option value="file11">github.com/dyaksa/warehouse/api/route/product_route.go (0.0%)</option>
				
				<option value="file12">github.com/dyaksa/warehouse/api/route/route.go (0.0%)</option>
				
				<option value="file13">github.com/dyaksa/warehouse/api/route/shop_route.go (0.0%)</option>
				
				<option value="file14">github.com/dyaksa/warehouse/api/route/stock_release_route.go (0.0%)</option>
				
				<option value="file15">github.com/dyaksa/warehouse/api/route/user_route.go (0.0%)</option>
				
				<option value="file16">github.com/dyaksa/warehouse/api/route/warehouse_route.go (0.0%)</option>
				
				<option value="file17">github.com/dyaksa/warehouse/api/route/warehouse_transfer_route.go (0.0%)</option>
				
				<option value="file18">github.com/dyaksa/warehouse/api/worker/stock_release_worker.go (0.0%)</option>
				
				<option value="file19">github.com/dyaksa/warehouse/bootstrap/app.go (0.0%)</option>
				
				<option value="file20">github.com/dyaksa/warehouse/bootstrap/crypto.go (0.0%)</option>
				
				<option value="file21">github.com/dyaksa/warehouse/bootstrap/env.go (0.0%)</option>
				
				<option value="file22">github.com/dyaksa/warehouse/bootstrap/postgres.go (0.0%)</option>
				
				<option value="file23">github.com/dyaksa/warehouse/docs/docs.go (0.0%)</option>
				
				<option value="file24">github.com/dyaksa/warehouse/domain/auth.go (0.0%)</option>
				
				<option value="file25">github.com/dyaksa/warehouse/infrastructure/crypto/crypto.go (0.0%)</option>
				
				<option value="file26">github.com/dyaksa/warehouse/infrastructure/pqsql/postgres.go (0.0%)</option>
				
				<option value="file27">github.com/dyaksa/warehouse/infrastructure/pqsql/wraptx.go (0.0%)</option>
				
				<option value="file28">github.com/dyaksa/warehouse/main.go (0.0%)</option>
				
				<option value="file29">github.com/dyaksa/warehouse/mocks/crypto/crypto_mock.go (0.0%)</option>
				
				<option value="file30">github.com/dyaksa/warehouse/mocks/pqsql/client_mock.go (0.0%)</option>
				
				<option value="file31">github.com/dyaksa/warehouse/mocks/pqsql/database_mock.go (0.0%)</option>
				
				<option value="file32">github.com/dyaksa/warehouse/mocks/repository/idempotency_request_repository_mock.go (0.0%)</option>
				
				<option value="file33">github.com/dyaksa/warehouse/mocks/repository/movement_repository_mock.go (0.0%)</option>
				
				<option value="file34">github.com/dyaksa/warehouse/mocks/repository/order_item_repository_mock.go (0.0%)</option>
				
				<option value="file35">github.com/dyaksa/warehouse/mocks/repository/order_repository_mock.go (0.0%)</option>
				
				<option value="file36">github.com/dyaksa/warehouse/mocks/repository/product_repository_mock.go (0.0%)</option>
				
				<option value="file37">github.com/dyaksa/warehouse/mocks/repository/product_stock_repository_mock.go (0.0%)</option>
				
				<option value="file38">github.com/dyaksa/warehouse/mocks/repository/reservation_repository_mock.go (0.0%)</option>
				
				<option value="file39">github.com/dyaksa/warehouse/mocks/repository/shop_repository_mock.go (0.0%)</option>
				
				<option value="file40">github.com/dyaksa/warehouse/mocks/repository/user_repository_mock.go (0.0%)</option>
				
				<option value="file41">github.com/dyaksa/warehouse/mocks/repository/warehouse_repository_mock.go (0.0%)</option>
				
				<option value="file42">github.com/dyaksa/warehouse/mocks/repository/warehouse_transfer_repository_mock.go (0.0%)</option>
				
				<option value="file43">github.com/dyaksa/warehouse/pkg/hashutils/hashutils.go (0.0%)</option>
				
				<option value="file44">github.com/dyaksa/warehouse/pkg/helper/helper.go (0.0%)</option>
				
				<option value="file45">github.com/dyaksa/warehouse/pkg/log/global.go (0.0%)</option>
				
				<option value="file46">github.com/dyaksa/warehouse/pkg/log/logrus/logrus.go (0.0%)</option>
				
				<option value="file47">github.com/dyaksa/warehouse/pkg/paginator/offset.go (0.0%)</option>
				
				<option value="file48">github.com/dyaksa/warehouse/pkg/paginator/paginator.go (0.0%)</option>
				
				<option value="file49">github.com/dyaksa/warehouse/pkg/passwordutils/password_utils.go (0.0%)</option>
				
				<option value="file50">github.com/dyaksa/warehouse/pkg/ratelimit/store.go (0.0%)</option>
				
				<option value="file51">github.com/dyaksa/warehouse/pkg/response/response_error/response_failed.go (0.0%)</option>
				
				<option value="file52">github.com/dyaksa/warehouse/pkg/response/response_success/response_success.go (0.0%)</option>
				
				<option value="file53">github.com/dyaksa/warehouse/pkg/tokenutils/token_utils.go (0.0%)</option>
				
				<option value="file54">github.com/dyaksa/warehouse/pkg/validationutils/validatorutils.go (0.0%)</option>
				
				<option value="file55">github.com/dyaksa/warehouse/repository/idempotency_request_repository.go (0.0%)</option>
				
				<option value="file56">github.com/dyaksa/warehouse/repository/movement_repository.go (0.0%)</option>
				
				<option value="file57">github.com/dyaksa/warehouse/repository/order_item_repository.go (0.0%)</option>
				
				<option value="file58">github.com/dyaksa/warehouse/repository/order_repository.go (0.0%)</option>
				
				<option value="file59">github.com/dyaksa/warehouse/repository/product_repository.go (0.0%)</option>
				
				<option value="file60">github.com/dyaksa/warehouse/repository/product_stock_repository.go (0.0%)</option>
				
				<option value="file61">github.com/dyaksa/warehouse/repository/reservation_repository.go (0.0%)</option>
				
				<option value="file62">github.com/dyaksa/warehouse/repository/shop_repository.go (0.0%)</option>
				
				<option value="file63">github.com/dyaksa/warehouse/repository/user_repository.go (0.0%)</option>
				
				<option value="file64">github.com/dyaksa/warehouse/repository/warehouse_repository.go (0.0%)</option>
				
				<option value="file65">github.com/dyaksa/warehouse/repository/warehouse_transfer_repository.go (0.0%)</option>
				
				<option value="file66">github.com/dyaksa/warehouse/usecase/auth_usecase.go (88.9%)</option>
				
				<option value="file67">github.com/dyaksa/warehouse/usecase/order_usecase.go (43.0%)</option>
				
				<option value="file68">github.com/dyaksa/warehouse/usecase/product_usecase.go (88.9%)</option>
				
				<option value="file69">github.com/dyaksa/warehouse/usecase/shop_usecase.go (100.0%)</option>
				
				<option value="file70">github.com/dyaksa/warehouse/usecase/stock_release_usecase.go (86.0%)</option>
				
				<option value="file71">github.com/dyaksa/warehouse/usecase/warehouse_transfer_usecase.go (72.9%)</option>
				
				<option value="file72">github.com/dyaksa/warehouse/usecase/warehouse_usecase.go (96.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
)

type AuthController struct {
        AuthUsecase domain.AuthUsecase
}

// Register creates a new user account
// @Summary Register a new user
// @Description Create a new user account with email, phone, and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param user body domain.AuthRegisterRequest true "User registration data"
// @Success 201 {object} map[string]interface{} "User registered successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request payload or validation failed"
// @Failure 500 {object} map[string]interface{} "Failed to register user"
// @Router /auth/register [post]
func (ac *AuthController) Register(c *gin.Context) <span class="cov0" title="0">{
        var payload domain.AuthRegisterRequest

        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                response_success.JSON(c).Msg("Invalid request payload").Status("error").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">_, err := ac.AuthUsecase.Register(c.Request.Context(), payload)
        if err != nil </span><span class="cov0" title="0">{
                response_success.JSON(c).Msg("Failed to register user").Status("error").Send(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("User registered successfully").Status("success").Send(http.StatusCreated)</span>
}

// Login authenticates a user and returns a JWT token
// @Summary User login
// @Description Authenticate user with email/phone and password, returns JWT access token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param credentials body domain.AuthLoginRequest true "User login credentials"
// @Success 200 {object} map[string]interface{} "Login successful with access token"
// @Failure 400 {object} map[string]interface{} "Invalid request payload"
// @Failure 401 {object} map[string]interface{} "Invalid credentials"
// @Failure 500 {object} map[string]interface{} "Failed to login"
// @Router /auth/login [post]
func (ac *AuthController) Login(c *gin.Context) <span class="cov0" title="0">{
        var payload domain.AuthLoginRequest

        if err := c.ShouldBindJSON(&amp;payload); err != nil </span><span class="cov0" title="0">{
                response_success.JSON(c).Msg("Invalid request payload").Status("error").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">token, err := ac.AuthUsecase.Login(c.Request.Context(), payload)
        if err != nil </span><span class="cov0" title="0">{
                response_success.JSON(c).Msg("Failed to login").Status("error").Send(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("Login successful").Status("success").Data(gin.H{"access_token": token}).Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/paginator"
        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type OrderController struct {
        OrderUsecase domain.OrderUsecase
}

func (oc *OrderController) Checkout(c *gin.Context) <span class="cov0" title="0">{
        var body domain.CheckoutInput
        body.UserID = c.GetString("x-user-id")

        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("validation failed").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">result, err := oc.OrderUsecase.Checkout(c.Request.Context(), body)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success checkout order").Status("success").Data(result).Send(http.StatusOK)</span>
}

// ConfirmPayment handles payment confirmation for an order
func (oc *OrderController) ConfirmPayment(c *gin.Context) <span class="cov0" title="0">{
        orderIDParam := c.Param("orderID")
        orderID, err := uuid.Parse(orderIDParam)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid order ID format").Status("validation failed").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = oc.OrderUsecase.ConfirmPayment(c.Request.Context(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("payment confirmation failed").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("payment confirmed successfully").Status("success").Send(http.StatusOK)</span>
}

// CancelOrder handles order cancellation
func (oc *OrderController) CancelOrder(c *gin.Context) <span class="cov0" title="0">{
        orderIDParam := c.Param("orderID")
        orderID, err := uuid.Parse(orderIDParam)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid order ID format").Status("validation failed").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = oc.OrderUsecase.CancelOrder(c.Request.Context(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("order cancellation failed").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("order cancelled successfully").Status("success").Send(http.StatusOK)</span>
}

// GetOrderDetails retrieves order details
func (oc *OrderController) GetOrderDetails(c *gin.Context) <span class="cov0" title="0">{
        orderIDParam := c.Param("orderID")
        orderID, err := uuid.Parse(orderIDParam)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid order ID format").Status("validation failed").Send(http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">order, err := oc.OrderUsecase.GetOrderDetails(c.Request.Context(), orderID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("order not found").Send(http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("order details retrieved successfully").Status("success").Data(order).Send(http.StatusOK)</span>
}

// GetUserOrders retrieves all orders for the authenticated user with pagination
func (oc *OrderController) GetUserOrders(c *gin.Context) <span class="cov0" title="0">{
        // Get user ID from JWT token
        userIDStr := c.GetString("x-user-id")
        userID, err := uuid.Parse(userIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid user ID").Status("authentication error").Send(http.StatusUnauthorized)
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">var pagination paginator.PaginationRequest
        if err := c.ShouldBindQuery(&amp;pagination); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("validation failed").Send(http.StatusBadRequest)
                return
        }</span>

        // Get user orders
        <span class="cov0" title="0">result, err := oc.OrderUsecase.GetUserOrders(c.Request.Context(), userID, pagination)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("failed to retrieve orders").Send(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("orders retrieved successfully").Status("success").Data(result).Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/paginator"
        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
)

type ProductController struct {
        ProductUsecase domain.ProductUsecase
}

// Create creates a new product with initial stock in the specified warehouse
// @Summary Create a new product
// @Description Create a new product with SKU, name, and initial stock quantity in a warehouse
// @Tags Products
// @Accept json
// @Produce json
// @Param product body domain.CreateProductRequest true "Product creation data"
// @Success 201 {object} map[string]interface{} "Product created successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request payload or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /products [post]
func (pc *ProductController) Create(c *gin.Context) <span class="cov0" title="0">{
        var body domain.CreateProductRequest

        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("validation failed").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := pc.ProductUsecase.Create(c.Request.Context(), body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success create products").Status("success").Send(http.StatusCreated)</span>
}

// RetrieveAll retrieves all products with pagination
// @Summary Get all products
// @Description Retrieve all products with pagination support and warehouse information
// @Tags Products
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Number of items per page" default(10)
// @Param offset query int false "Offset for pagination" default(0)
// @Success 200 {object} map[string]interface{} "Products retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid pagination parameters"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /products [get]
func (pc *ProductController) RetrieveAll(c *gin.Context) <span class="cov0" title="0">{
        var pagination paginator.PaginationRequest

        if err := c.ShouldBindQuery(&amp;pagination); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("validation failed").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">result, err := pc.ProductUsecase.RetrieveAll(c.Request.Context(), pagination)

        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success retrieve products").Status("success").Data(result).Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
)

type ShopController struct {
        ShopUsecase domain.ShopUsecase
}

func (sc *ShopController) Create(c *gin.Context) <span class="cov0" title="0">{
        var body domain.CreateShopRequest

        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := sc.ShopUsecase.Create(c.Request.Context(), body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success create shop").Status("success").Send(http.StatusCreated)</span>
}

func (sc *ShopController) Retrieve(c *gin.Context) <span class="cov0" title="0">{
        var query domain.ShopQuery
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">shop, err := sc.ShopUsecase.Retrieve(c.Request.Context(), query.ID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success retrieve shop").Data(shop).Send(http.StatusOK)</span>
}

func (sc *ShopController) Update(c *gin.Context) <span class="cov0" title="0">{
        var body domain.UpdateShopRequest
        if err := c.ShouldBind(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := sc.ShopUsecase.Update(c.Request.Context(), body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success update shop").Status("success").Send(http.StatusOK)</span>
}

func (sc *ShopController) Delete(c *gin.Context) <span class="cov0" title="0">{
        var query domain.ShopQuery
        if err := c.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := sc.ShopUsecase.Delete(c.Request.Context(), query.ID); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success delete shop").Status("success").Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/api/worker"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
)

type StockReleaseController struct {
        stockReleaseWorker *worker.StockReleaseWorker
}

func NewStockReleaseController(stockReleaseWorker *worker.StockReleaseWorker) *StockReleaseController <span class="cov0" title="0">{
        return &amp;StockReleaseController{
                stockReleaseWorker: stockReleaseWorker,
        }
}</span>

// ManualRelease manually triggers the stock release process
func (src *StockReleaseController) ManualRelease(c *gin.Context) <span class="cov0" title="0">{
        err := src.stockReleaseWorker.ProcessNow(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to process stock release",
                        "message": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).
                Status("success").
                Msg("Stock release processing triggered successfully").
                Send(http.StatusOK)</span>
}

// Status returns the status of the stock release worker
func (src *StockReleaseController) Status(c *gin.Context) <span class="cov0" title="0">{
        response_success.JSON(c).
                Status("success").
                Msg("Stock release worker is running").
                Data(gin.H{
                        "worker_status": "active",
                }).
                Send(http.StatusOK)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "net/http"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type WarehouseController struct {
        WarehouseUsecase domain.WarehouseUsecase
}

// Create creates a new warehouse for a shop
// @Summary Create a new warehouse
// @Description Create a new warehouse associated with a shop
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param warehouse body domain.WarehouseCreateRequest true "Warehouse creation data"
// @Success 201 {object} map[string]interface{} "Warehouse created successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request payload or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses [post]
func (w *WarehouseController) Create(c *gin.Context) <span class="cov0" title="0">{
        var body domain.WarehouseCreateRequest

        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := w.WarehouseUsecase.Create(c.Request.Context(), body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("success create warehouse").Status("success").Send(http.StatusCreated)</span>
}

// Retrieve gets a warehouse by ID
// @Summary Get warehouse by ID
// @Description Retrieve a specific warehouse by its UUID
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param id path string true "Warehouse ID (UUID)" format(uuid)
// @Success 200 {object} map[string]interface{} "Warehouse retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid warehouse ID format"
// @Failure 404 {object} map[string]interface{} "Warehouse not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses/{id} [get]
func (w *WarehouseController) Retrieve(c *gin.Context) <span class="cov0" title="0">{
        warehouseIDStr := c.Param("id")
        warehouseID, err := uuid.Parse(warehouseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid warehouse ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">warehouse, err := w.WarehouseUsecase.Retrieve(c.Request.Context(), warehouseID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Data(warehouse).Msg("warehouse retrieved successfully").Status("success").Send(http.StatusOK)</span>
}

// Update updates a warehouse by ID
// @Summary Update warehouse
// @Description Update an existing warehouse by its UUID
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param id path string true "Warehouse ID (UUID)" format(uuid)
// @Param warehouse body domain.WarehouseCreateRequest true "Updated warehouse data"
// @Success 200 {object} map[string]interface{} "Warehouse updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid warehouse ID or request payload"
// @Failure 404 {object} map[string]interface{} "Warehouse not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses/{id} [put]
func (w *WarehouseController) Update(c *gin.Context) <span class="cov0" title="0">{
        warehouseIDStr := c.Param("id")
        warehouseID, err := uuid.Parse(warehouseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid warehouse ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">var body domain.WarehouseCreateRequest
        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := w.WarehouseUsecase.Update(c.Request.Context(), warehouseID, body); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("warehouse updated successfully").Status("success").Send(http.StatusOK)</span>
}

// Delete deletes a warehouse by ID
// @Summary Delete warehouse
// @Description Delete an existing warehouse by its UUID
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param id path string true "Warehouse ID (UUID)" format(uuid)
// @Success 200 {object} map[string]interface{} "Warehouse deleted successfully"
// @Failure 400 {object} map[string]interface{} "Invalid warehouse ID format"
// @Failure 404 {object} map[string]interface{} "Warehouse not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses/{id} [delete]
func (w *WarehouseController) Delete(c *gin.Context) <span class="cov0" title="0">{
        warehouseIDStr := c.Param("id")
        warehouseID, err := uuid.Parse(warehouseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid warehouse ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := w.WarehouseUsecase.Delete(c.Request.Context(), warehouseID); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("warehouse deleted successfully").Status("success").Send(http.StatusOK)</span>
}

// SetActive updates warehouse active status
// @Summary Set warehouse active status
// @Description Enable or disable a warehouse by updating its active status
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param id path string true "Warehouse ID (UUID)" format(uuid)
// @Param status body object{is_active=bool} true "Active status data"
// @Success 200 {object} map[string]interface{} "Warehouse status updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid warehouse ID or request payload"
// @Failure 404 {object} map[string]interface{} "Warehouse not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses/{id}/status [patch]
func (w *WarehouseController) SetActive(c *gin.Context) <span class="cov0" title="0">{
        warehouseIDStr := c.Param("id")
        warehouseID, err := uuid.Parse(warehouseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid warehouse ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                IsActive bool `json:"is_active" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := w.WarehouseUsecase.SetActive(c.Request.Context(), warehouseID, req.IsActive); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("warehouse status updated successfully").Status("success").Send(http.StatusOK)</span>
}

// GetByShop gets warehouses by shop ID
// @Summary Get warehouses by shop ID
// @Description Retrieve all warehouses associated with a specific shop
// @Tags Warehouses
// @Accept json
// @Produce json
// @Param shop_id path string true "Shop ID (UUID)" format(uuid)
// @Success 200 {object} map[string]interface{} "Warehouses retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid shop ID format"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /shops/{shop_id}/warehouses [get]
func (w *WarehouseController) GetByShop(c *gin.Context) <span class="cov0" title="0">{
        shopIDStr := c.Param("shop_id")
        shopID, err := uuid.Parse(shopIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid shop ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">warehouses, err := w.WarehouseUsecase.GetByShopID(c.Request.Context(), shopID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Data(warehouses).Msg("warehouses retrieved successfully").Status("success").Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "net/http"
        "strconv"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/response/response_success"
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

type WarehouseTransferController struct {
        TransferUsecase domain.WarehouseTransferUsecase
}

// CreateTransfer creates a new warehouse transfer
// @Summary Create a new warehouse transfer
// @Description Create a transfer request to move products between warehouses with specified items and quantities
// @Tags Warehouse Transfers
// @Accept json
// @Produce json
// @Param transfer body domain.CreateTransferRequest true "Transfer creation data with items"
// @Success 201 {object} map[string]interface{} "Transfer created successfully"
// @Failure 400 {object} map[string]interface{} "Invalid request payload or validation failed"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /transfers [post]
func (wtc *WarehouseTransferController) CreateTransfer(c *gin.Context) <span class="cov0" title="0">{
        var req domain.CreateTransferRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">transfer, err := wtc.TransferUsecase.CreateTransfer(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Data(transfer).Msg("transfer created successfully").Status("success").Send(http.StatusCreated)</span>
}

// GetTransfer retrieves a warehouse transfer by ID
// @Summary Get warehouse transfer by ID
// @Description Retrieve a specific warehouse transfer with all its details and items
// @Tags Warehouse Transfers
// @Accept json
// @Produce json
// @Param id path string true "Transfer ID (UUID)" format(uuid)
// @Success 200 {object} map[string]interface{} "Transfer retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid transfer ID format"
// @Failure 404 {object} map[string]interface{} "Transfer not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /transfers/{id} [get]
func (wtc *WarehouseTransferController) GetTransfer(c *gin.Context) <span class="cov0" title="0">{
        transferIDStr := c.Param("id")
        transferID, err := uuid.Parse(transferIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid transfer ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">transfer, err := wtc.TransferUsecase.GetTransfer(c.Request.Context(), transferID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Data(transfer).Msg("transfer retrieved successfully").Status("success").Send(http.StatusOK)</span>
}

// UpdateTransferStatus updates the status of a warehouse transfer
// @Summary Update transfer status
// @Description Update the status of a warehouse transfer (REQUESTED, APPROVED, IN_TRANSIT, COMPLETED, CANCELLED)
// @Tags Warehouse Transfers
// @Accept json
// @Produce json
// @Param id path string true "Transfer ID (UUID)" format(uuid)
// @Param status body domain.UpdateTransferStatusRequest true "New transfer status"
// @Success 200 {object} map[string]interface{} "Transfer status updated successfully"
// @Failure 400 {object} map[string]interface{} "Invalid transfer ID or status"
// @Failure 404 {object} map[string]interface{} "Transfer not found"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /transfers/{id}/status [patch]
func (wtc *WarehouseTransferController) UpdateTransferStatus(c *gin.Context) <span class="cov0" title="0">{
        transferIDStr := c.Param("id")
        transferID, err := uuid.Parse(transferIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid transfer ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">var req domain.UpdateTransferStatusRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">err = wtc.TransferUsecase.UpdateTransferStatus(c.Request.Context(), transferID, req)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("transfer status updated successfully").Status("success").Send(http.StatusOK)</span>
}

// GetTransfersByWarehouse retrieves transfers associated with a warehouse
// @Summary Get transfers by warehouse
// @Description Retrieve all transfers where the warehouse is either source or destination with pagination
// @Tags Warehouse Transfers
// @Accept json
// @Produce json
// @Param warehouse_id path string true "Warehouse ID (UUID)" format(uuid)
// @Param limit query int false "Number of items per page" default(10)
// @Param offset query int false "Offset for pagination" default(0)
// @Success 200 {object} map[string]interface{} "Transfers retrieved successfully"
// @Failure 400 {object} map[string]interface{} "Invalid warehouse ID or pagination parameters"
// @Failure 500 {object} map[string]interface{} "Internal server error"
// @Security BearerAuth
// @Router /warehouses/{warehouse_id}/transfers [get]
func (wtc *WarehouseTransferController) GetTransfersByWarehouse(c *gin.Context) <span class="cov0" title="0">{
        warehouseIDStr := c.Param("warehouse_id")
        warehouseID, err := uuid.Parse(warehouseIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid warehouse ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        // Parse pagination parameters
        <span class="cov0" title="0">limitStr := c.DefaultQuery("limit", "10")
        offsetStr := c.DefaultQuery("offset", "0")

        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
        if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">transfers, total, err := wtc.TransferUsecase.GetTransfersByWarehouse(c.Request.Context(), warehouseID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "transfers": transfers,
                "total":     total,
                "limit":     limit,
                "offset":    offset,
        }

        response_success.JSON(c).Data(result).Msg("transfers retrieved successfully").Status("success").Send(http.StatusOK)</span>
}

// ExecuteTransfer executes a warehouse transfer
// @Summary Execute warehouse transfer
// @Description Execute an approved transfer to actually move stock between warehouses
// @Tags Warehouse Transfers
// @Accept json
// @Produce json
// @Param id path string true "Transfer ID (UUID)" format(uuid)
// @Success 200 {object} map[string]interface{} "Transfer executed successfully"
// @Failure 400 {object} map[string]interface{} "Invalid transfer ID or transfer not in executable state"
// @Failure 404 {object} map[string]interface{} "Transfer not found"
// @Failure 500 {object} map[string]interface{} "Internal server error or execution failed"
// @Security BearerAuth
// @Router /transfers/{id}/execute [post]
func (wtc *WarehouseTransferController) ExecuteTransfer(c *gin.Context) <span class="cov0" title="0">{
        transferIDStr := c.Param("id")
        transferID, err := uuid.Parse(transferIDStr)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg("invalid transfer ID").Status("error validation").Send(http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">err = wtc.TransferUsecase.ExecuteTransfer(c.Request.Context(), transferID)
        if err != nil </span><span class="cov0" title="0">{
                response_error.JSON(c).Msg(err.Error()).Status("internal server error").Send(http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">response_success.JSON(c).Msg("transfer executed successfully").Status("success").Send(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/dyaksa/warehouse/pkg/response/response_error"
        "github.com/dyaksa/warehouse/pkg/tokenutils"
        "github.com/gin-gonic/gin"
)

func JwtAuthMiddleware(secret string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.Request.Header.Get("Authorization")
                t := strings.Split(authHeader, " ")
                if len(t) == 2 </span><span class="cov0" title="0">{
                        authToken := t[1]
                        authorized, err := tokenutils.IsAuthorized(authToken, secret)
                        if authorized </span><span class="cov0" title="0">{
                                userID, err := tokenutils.ExtractIDFromToken(authToken, secret)
                                if err != nil </span><span class="cov0" title="0">{
                                        response_error.JSON(c).Msg("Failed to extract user ID from token").Status("error").Send(http.StatusUnauthorized)
                                        c.Abort()
                                        return
                                }</span>
                                <span class="cov0" title="0">c.Set("x-user-id", userID)
                                c.Next()
                                return</span>
                        }
                        <span class="cov0" title="0">response_error.JSON(c).Msg(err.Error()).Status("error").Send(http.StatusUnauthorized)
                        c.Abort()
                        return</span>
                }
                <span class="cov0" title="0">response_error.JSON(c).Msg("Not authorized").Status("error").Send(http.StatusUnauthorized)
                c.Abort()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package middleware

import (
        "fmt"
        "time"

        "github.com/dyaksa/warehouse/pkg/ratelimit"
        "github.com/gin-gonic/gin"
)

type Options func(*ratelimit.Options)

func keyFunc(ctx *gin.Context) string <span class="cov0" title="0">{
        return ctx.ClientIP()
}</span>

func errorHandler(ctx *gin.Context, info ratelimit.Info) <span class="cov0" title="0">{
        ctx.Header("X-RateLimit-Limit", fmt.Sprintf("%d", info.Limit))
        ctx.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", info.RemainingHits))
        ctx.Header("X-RateLimit-Reset", fmt.Sprintf("%d", info.ResetTime.Unix()))
        ctx.String(429, "Too Many Requests")
}</span>

func beforeResponse(ctx *gin.Context, info ratelimit.Info) <span class="cov0" title="0">{
        ctx.Header("X-RateLimit-Limit", fmt.Sprintf("%d", info.Limit))
        ctx.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", info.RemainingHits))
        ctx.Header("X-RateLimit-Reset", fmt.Sprintf("%d", info.ResetTime.Unix()))
}</span>

func RateLimit(store ratelimit.Store) gin.HandlerFunc <span class="cov0" title="0">{
        options := &amp;ratelimit.Options{
                KeyFunc:        keyFunc,
                ErrorHandler:   errorHandler,
                BeforeResponse: beforeResponse,
        }

        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                key := options.KeyFunc(ctx)
                info := store.Limit(key, ctx)
                options.BeforeResponse(ctx, info)

                if ctx.IsAborted() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">if info.RateLimited </span><span class="cov0" title="0">{
                        options.ErrorHandler(ctx, info)
                        ctx.Abort()
                }</span> else<span class="cov0" title="0"> {
                        ctx.Next()
                }</span>
        }
}

func RateLimitDefault() gin.HandlerFunc <span class="cov0" title="0">{
        return RateLimit(ratelimit.InMemoryStore(&amp;ratelimit.InMemoryOptions{
                Rate:  time.Second,
                Limit: 100,
        }))
}</span>

// RateLimitRedisCustom creates a Redis-based rate limiter with custom settings
func RateLimitMiddleware(rate time.Duration, limit uint, prefix string) gin.HandlerFunc <span class="cov0" title="0">{
        return RateLimit(ratelimit.InMemoryStore(&amp;ratelimit.InMemoryOptions{
                Rate:  rate,
                Limit: limit,
        }))
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewAuthRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        userRepository := repository.NewUserRepository(db)
        authUsecase := usecase.NewAuthUsecase(userRepository, crypto, env)

        authController := controller.AuthController{
                AuthUsecase: authUsecase,
        }

        authGroup := group.Group("/auth")
        authGroup.POST("/register", authController.Register)
        authGroup.POST("/login", authController.Login)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewOrderRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        jwtMiddleware := middleware.JwtAuthMiddleware(env.JwtSecret)
        orderRepository := repository.NewOrderRepository(db)
        idempotencyRepository := repository.NewIdempotencyRequestRepository(db)
        orderItemRepository := repository.NewOrderItemRepository(db)
        reservationRepository := repository.NewReservationRepository(db)
        movementRepository := repository.NewMovementRepository(db)
        productStockRepository := repository.NewProductStockRepository(db)
        pickWarehouseRepository := repository.NewWarehouseRepository(db)

        orderController := controller.OrderController{
                OrderUsecase: usecase.NewOrderUsecase(
                        db.Database(),
                        orderRepository,
                        idempotencyRepository,
                        orderItemRepository,
                        reservationRepository,
                        movementRepository,
                        productStockRepository,
                        pickWarehouseRepository,
                ),
        }

        groupOrder := group.Group("/order", jwtMiddleware)
        groupOrder.POST("/checkout", orderController.Checkout)
        groupOrder.POST("/:orderID/confirm-payment", orderController.ConfirmPayment)
        groupOrder.POST("/:orderID/cancel", orderController.CancelOrder)
        groupOrder.GET("/:orderID", orderController.GetOrderDetails)
        groupOrder.GET("/list", orderController.GetUserOrders)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewProductRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        jwtMiddleware := middleware.JwtAuthMiddleware(env.JwtSecret)
        productRepository := repository.NewProductRepository(db)
        productStockRepository := repository.NewProductStockRepository(db)
        productUsecase := usecase.NewProductUsecase(productRepository, productStockRepository)

        productController := controller.ProductController{
                ProductUsecase: productUsecase,
        }

        groupProduct := group.Group("/product")

        groupProduct.POST("/create", jwtMiddleware, productController.Create)
        groupProduct.GET("/list", jwtMiddleware, productController.RetrieveAll)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func Setup(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, r *gin.Engine) <span class="cov0" title="0">{
        publicGroup := r.Group("/api")

        NewAuthRoute(env, timeout, db, l, crypto, publicGroup)
        NewWarehouseRoute(env, timeout, db, l, crypto, publicGroup)
        NewWarehouseTransferRoute(env, timeout, db, l, crypto, publicGroup)
        NewProductRoute(env, timeout, db, l, crypto, publicGroup)
        NewShopRoute(env, timeout, db, l, crypto, publicGroup)
        NewOrderRoute(env, timeout, db, l, crypto, publicGroup)

        swaggerRoute := r.Group("/swagger")
        </span><span class="cov0" title="0">{
                swaggerRoute.GET("/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewShopRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        jwtMiddleware := middleware.JwtAuthMiddleware(env.JwtSecret)
        shopRepository := repository.NewShopRepository(db)
        shopUsecase := usecase.NewShopUsecase(shopRepository)

        shopController := controller.ShopController{
                ShopUsecase: shopUsecase,
        }

        shopGroup := group.Group("/shop", jwtMiddleware)
        shopGroup.POST("/create", shopController.Create)
        shopGroup.GET("/retrieve", shopController.Retrieve)
        shopGroup.PUT("/update", shopController.Update)
        shopGroup.DELETE("/delete", shopController.Delete)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/api/worker"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/gin-gonic/gin"
)

func NewStockReleaseRoute(
        env *bootstrap.Env,
        timeout time.Duration,
        db pqsql.Client,
        log log.Logger,
        crypto crypto.Crypto,
        gin *gin.Engine,
        stockReleaseWorker *worker.StockReleaseWorker,
) <span class="cov0" title="0">{
        stockReleaseController := controller.NewStockReleaseController(stockReleaseWorker)
        stockReleaseGroup := gin.Group("/api/stock-release")
        stockReleaseGroup.Use(middleware.JwtAuthMiddleware(env.JwtSecret))
        stockReleaseGroup.POST("/trigger", stockReleaseController.ManualRelease)
        stockReleaseGroup.GET("/status", stockReleaseController.Status)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/gin-gonic/gin"
)

func NewUserRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewWarehouseRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        jwtMiddleware := middleware.JwtAuthMiddleware(env.JwtSecret)
        wareHouseRepository := repository.NewWarehouseRepository(db)
        warehouseTransferRepository := repository.NewWarehouseTransferRepository(db)
        wareHouseUsecase := usecase.NewWarehouseUsecase(wareHouseRepository, warehouseTransferRepository)

        wareHouseController := controller.WarehouseController{
                WarehouseUsecase: wareHouseUsecase,
        }

        warehouseGroup := group.Group("/warehouse", jwtMiddleware)
        warehouseGroup.POST("/create", wareHouseController.Create)
        warehouseGroup.GET("/:id", wareHouseController.Retrieve)
        warehouseGroup.PUT("/:id", wareHouseController.Update)
        warehouseGroup.DELETE("/:id", wareHouseController.Delete)
        warehouseGroup.PUT("/:id/status", wareHouseController.SetActive)
        warehouseGroup.GET("/shop/:shop_id", wareHouseController.GetByShop)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package route

import (
        "time"

        "github.com/dyaksa/warehouse/api/controller"
        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-gonic/gin"
)

func NewWarehouseTransferRoute(env *bootstrap.Env, timeout time.Duration, db pqsql.Client, l log.Logger, crypto crypto.Crypto, group *gin.RouterGroup) <span class="cov0" title="0">{
        jwtMiddleware := middleware.JwtAuthMiddleware(env.JwtSecret)

        // Initialize repositories
        warehouseTransferRepo := repository.NewWarehouseTransferRepository(db)
        warehouseRepo := repository.NewWarehouseRepository(db)
        productStockRepo := repository.NewProductStockRepository(db)
        movementRepo := repository.NewMovementRepository(db)

        // Initialize usecase
        warehouseTransferUsecase := usecase.NewWarehouseTransferUsecase(
                db.Database(),
                warehouseTransferRepo,
                warehouseRepo,
                productStockRepo,
                movementRepo,
        )

        // Initialize controller
        warehouseTransferController := controller.WarehouseTransferController{
                TransferUsecase: warehouseTransferUsecase,
        }

        // Create route group
        transferGroup := group.Group("/transfers", jwtMiddleware)
        transferGroup.POST("/", warehouseTransferController.CreateTransfer)
        transferGroup.GET("/:id", warehouseTransferController.GetTransfer)
        transferGroup.PUT("/:id/status", warehouseTransferController.UpdateTransferStatus)
        transferGroup.POST("/:id/execute", warehouseTransferController.ExecuteTransfer)
        transferGroup.GET("/warehouse/:warehouse_id", warehouseTransferController.GetTransfersByWarehouse)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package worker

import (
        "context"
        "log"
        "time"

        "github.com/dyaksa/warehouse/usecase"
)

type StockReleaseWorker struct {
        stockReleaseUsecase usecase.StockReleaseUsecase
        batchSize           int
        interval            time.Duration
        stopCh              chan struct{}
}

type StockReleaseWorkerConfig struct {
        BatchSize int           // Number of reservations to process per batch
        Interval  time.Duration // How often to check for expired reservations
}

func NewStockReleaseWorker(
        stockReleaseUsecase usecase.StockReleaseUsecase,
        config StockReleaseWorkerConfig,
) *StockReleaseWorker <span class="cov0" title="0">{
        // Set default values if not provided
        if config.BatchSize &lt;= 0 </span><span class="cov0" title="0">{
                config.BatchSize = 100
        }</span>
        <span class="cov0" title="0">if config.Interval &lt;= 0 </span><span class="cov0" title="0">{
                config.Interval = 30 * time.Second // Check every 30 seconds by default
        }</span>

        <span class="cov0" title="0">return &amp;StockReleaseWorker{
                stockReleaseUsecase: stockReleaseUsecase,
                batchSize:           config.BatchSize,
                interval:            config.Interval,
                stopCh:              make(chan struct{}),
        }</span>
}

// Start begins the background worker that periodically processes expired reservations
func (w *StockReleaseWorker) Start(ctx context.Context) <span class="cov0" title="0">{
        log.Printf("Starting stock release worker with batch size %d and interval %v", w.batchSize, w.interval)

        ticker := time.NewTicker(w.interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Println("Stock release worker stopped due to context cancellation")
                        return</span>
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        log.Println("Stock release worker stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        w.processExpiredReservations(ctx)</span>
                }
        }
}

// Stop gracefully stops the worker
func (w *StockReleaseWorker) Stop() <span class="cov0" title="0">{
        close(w.stopCh)
}</span>

// StartWithGracefulShutdown starts the worker and handles graceful shutdown
func (w *StockReleaseWorker) StartWithGracefulShutdown(ctx context.Context) <span class="cov0" title="0">{
        go w.Start(ctx)

        // Wait for context cancellation
        &lt;-ctx.Done()
        log.Println("Shutting down stock release worker...")
        w.Stop()
}</span>

func (w *StockReleaseWorker) processExpiredReservations(ctx context.Context) <span class="cov0" title="0">{
        start := time.Now()

        err := w.stockReleaseUsecase.ProcessExpiredReservations(ctx, w.batchSize)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error processing expired reservations: %v", err)
                return
        }</span>

        <span class="cov0" title="0">duration := time.Since(start)
        log.Printf("Processed expired reservations in %v", duration)</span>
}

// ProcessNow immediately processes expired reservations (useful for manual triggers)
func (w *StockReleaseWorker) ProcessNow(ctx context.Context) error <span class="cov0" title="0">{
        log.Println("Manually triggered stock release processing")
        return w.stockReleaseUsecase.ProcessExpiredReservations(ctx, w.batchSize)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package bootstrap

import (
        "context"

        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/pkg/log/logrus"
        "github.com/dyaksa/warehouse/pkg/validationutils"
        "github.com/gin-gonic/gin"
        "github.com/gin-gonic/gin/binding"
        "github.com/go-playground/validator/v10"
)

type Application struct {
        Env      *Env
        App      *gin.Engine
        Log      log.Logger
        Postgres pqsql.Client
        Crypto   crypto.Crypto
}

func App(ctx context.Context) *Application <span class="cov0" title="0">{
        app := &amp;Application{
                Env: NewEnv(ctx),
                App: gin.Default(),
        }

        ll, err := logrus.New(
                logrus.WithLevel("info"),
                logrus.WithJSONFormatter(),
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">app.Log = ll
        app.Postgres = NewPostgres(app.Env, app.Log)
        app.Crypto = NewDerivaleCrypto(app.Log)

        return app</span>
}

func (app *Application) CloseConnection() <span class="cov0" title="0">{
        CloseConnection(app.Postgres, app.Log)
}</span>

func (app *Application) CustomValidation() <span class="cov0" title="0">{
        if v, ok := binding.Validator.Engine().(*validator.Validate); ok </span><span class="cov0" title="0">{
                _ = validationutils.IdentifierValidator(v)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package bootstrap

import (
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/pkg/log"
)

func NewDerivaleCrypto(l log.Logger) crypto.Crypto <span class="cov0" title="0">{
        c, err := crypto.New()
        if err != nil </span><span class="cov0" title="0">{
                l.Error("failed to create crypto", log.Error("error", err))
        }</span>

        <span class="cov0" title="0">return c</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package bootstrap

import (
        "context"
        "log/slog"

        "github.com/joho/godotenv"
        "github.com/sethvargo/go-envconfig"
)

type Env struct {
        AppName  string `env:"APP_NAME" default:"boilerplate-go-clean-architecture"`
        AppEnv   string `env:"APP_ENV" default:"development"`
        Port     string `env:"APP_PORT" default:"8080"`
        LogLevel string `env:"LOG_LEVEL" default:"info"`

        DBHost string `env:"DB_HOST" default:"localhost"`
        DBPort string `env:"DB_PORT" default:"5432"`
        DBUser string `env:"DB_USER" default:"postgres"`
        DBPass string `env:"DB_PASS" default:"postgres"`
        DBName string `env:"DB_NAME" default:"postgres"`
        DBSSL  string `env:"DB_SSL" default:"disable"`

        ContextTimeout int `env:"CONTEXT_TIMEOUT" default:"10"`

        JwtSecret string `env:"JWT_SECRET" default:"secret"`
        JwtExpiry int    `env:"JWT_EXPIRY" default:"3600"`

        AutoMigrate bool   `env:"AUTO_MIGRATE" default:"false"`
        DB_DIALECT  string `env:"DB_DIALECT" default:"postgres"`
}

func NewEnv(ctx context.Context) *Env <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                slog.WarnContext(ctx, "failed to load env file")
        }</span>

        <span class="cov0" title="0">env := Env{}

        if err := envconfig.Process(ctx, &amp;env); err != nil </span><span class="cov0" title="0">{
                slog.WarnContext(ctx, "failed to process env vars")
        }</span>

        <span class="cov0" title="0">return &amp;env</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package bootstrap

import (
        "context"
        "fmt"
        "time"

        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/log"
)

func NewPostgres(env *Env, l log.Logger) pqsql.Client <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        dbHost := env.DBHost
        dbPort := env.DBPort
        dbUser := env.DBUser
        dbPass := env.DBPass
        dbName := env.DBName
        dbSSL := env.DBSSL

        client, err := pqsql.NewClient(fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s", dbHost, dbPort, dbUser, dbPass, dbName, dbSSL))
        if err != nil </span><span class="cov0" title="0">{
                l.Warn("failed to connect to postgres", log.Error("error", err))
        }</span>

        <span class="cov0" title="0">if err = client.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                l.Warn("failed to ping postgres", log.Error("error", err))
        }</span>

        <span class="cov0" title="0">return client</span>
}

func CloseConnection(client pqsql.Client, l log.Logger) <span class="cov0" title="0">{
        if client == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                l.Warn("failed to close postgres connection", log.Error("error", err))
        }</span>

        <span class="cov0" title="0">l.Info("postgres connection closed")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "produces": [
        "application/json"
    ],
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {},
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "Authenticate user with email/phone and password, returns JWT access token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "User login",
                "parameters": [
                    {
                        "description": "User login credentials",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.AuthLoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Login successful with access token",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "401": {
                        "description": "Invalid credentials",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Failed to login",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Create a new user account with email, phone, and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User registration data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.AuthRegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User registered successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request payload or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Failed to register user",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/products": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve all products with pagination support and warehouse information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Get all products",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Products retrieved successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid pagination parameters",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new product with SKU, name, and initial stock quantity in a warehouse",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Products"
                ],
                "summary": "Create a new product",
                "parameters": [
                    {
                        "description": "Product creation data",
                        "name": "product",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.CreateProductRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Product created successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request payload or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/shops/{shop_id}/warehouses": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve all warehouses associated with a specific shop",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Get warehouses by shop ID",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Shop ID (UUID)",
                        "name": "shop_id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouses retrieved successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid shop ID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/transfers": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a transfer request to move products between warehouses with specified items and quantities",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse Transfers"
                ],
                "summary": "Create a new warehouse transfer",
                "parameters": [
                    {
                        "description": "Transfer creation data with items",
                        "name": "transfer",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.CreateTransferRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Transfer created successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request payload or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/transfers/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a specific warehouse transfer with all its details and items",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse Transfers"
                ],
                "summary": "Get warehouse transfer by ID",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Transfer ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transfer retrieved successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid transfer ID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Transfer not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/transfers/{id}/execute": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Execute an approved transfer to actually move stock between warehouses",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse Transfers"
                ],
                "summary": "Execute warehouse transfer",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Transfer ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transfer executed successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid transfer ID or transfer not in executable state",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Transfer not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error or execution failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/transfers/{id}/status": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update the status of a warehouse transfer (REQUESTED, APPROVED, IN_TRANSIT, COMPLETED, CANCELLED)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse Transfers"
                ],
                "summary": "Update transfer status",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Transfer ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "New transfer status",
                        "name": "status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.UpdateTransferStatusRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transfer status updated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid transfer ID or status",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Transfer not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/warehouses": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Create a new warehouse associated with a shop",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Create a new warehouse",
                "parameters": [
                    {
                        "description": "Warehouse creation data",
                        "name": "warehouse",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.WarehouseCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Warehouse created successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid request payload or validation failed",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/warehouses/{id}": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve a specific warehouse by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Get warehouse by ID",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Warehouse ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouse retrieved successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid warehouse ID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Update an existing warehouse by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Update warehouse",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Warehouse ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated warehouse data",
                        "name": "warehouse",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/domain.WarehouseCreateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouse updated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid warehouse ID or request payload",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Delete an existing warehouse by its UUID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Delete warehouse",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Warehouse ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouse deleted successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid warehouse ID format",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/warehouses/{id}/status": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Enable or disable a warehouse by updating its active status",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouses"
                ],
                "summary": "Set warehouse active status",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Warehouse ID (UUID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Active status data",
                        "name": "status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object",
                            "properties": {
                                "is_active": {
                                    "type": "boolean"
                                }
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Warehouse status updated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid warehouse ID or request payload",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Warehouse not found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/warehouses/{warehouse_id}/transfers": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Retrieve all transfers where the warehouse is either source or destination with pagination",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Warehouse Transfers"
                ],
                "summary": "Get transfers by warehouse",
                "parameters": [
                    {
                        "type": "string",
                        "format": "uuid",
                        "description": "Warehouse ID (UUID)",
                        "name": "warehouse_id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 0,
                        "description": "Offset for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transfers retrieved successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Invalid warehouse ID or pagination parameters",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "domain.AuthLoginRequest": {
            "type": "object",
            "required": [
                "identifier",
                "password"
            ],
            "properties": {
                "identifier": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                }
            }
        },
        "domain.AuthRegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "password",
                "phone"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "user@example.com"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                },
                "phone": {
                    "type": "string",
                    "example": "+6281234567890"
                }
            }
        },
        "domain.CreateProductRequest": {
            "type": "object",
            "required": [
                "name",
                "sku",
                "warehouse_id"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "example": "Sample Product"
                },
                "on_hand": {
                    "type": "integer",
                    "example": 100
                },
                "sku": {
                    "type": "string",
                    "example": "PROD-001"
                },
                "warehouse_id": {
                    "type": "string",
                    "example": "550e8400-e29b-41d4-a716-446655440000"
                }
            }
        },
        "domain.CreateTransferItemRequest": {
            "type": "object",
            "required": [
                "product_id",
                "qty"
            ],
            "properties": {
                "product_id": {
                    "type": "string",
                    "example": "550e8400-e29b-41d4-a716-446655440004"
                },
                "qty": {
                    "type": "integer",
                    "minimum": 1,
                    "example": 10
                }
            }
        },
        "domain.CreateTransferRequest": {
            "type": "object",
            "required": [
                "from_warehouse_id",
                "items",
                "to_warehouse_id"
            ],
            "properties": {
                "from_warehouse_id": {
                    "type": "string",
                    "example": "550e8400-e29b-41d4-a716-446655440001"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/domain.CreateTransferItemRequest"
                    }
                },
                "to_warehouse_id": {
                    "type": "string",
                    "example": "550e8400-e29b-41d4-a716-446655440002"
                }
            }
        },
        "domain.TransferStatus": {
            "type": "string",
            "enum": [
                "REQUESTED",
                "APPROVED",
                "IN_TRANSIT",
                "COMPLETED",
                "CANCELLED"
            ],
            "x-enum-varnames": [
                "TransferStatusRequested",
                "TransferStatusApproved",
                "TransferStatusInTransit",
                "TransferStatusCompleted",
                "TransferStatusCancelled"
            ]
        },
        "domain.UpdateTransferStatusRequest": {
            "type": "object",
            "required": [
                "status"
            ],
            "properties": {
                "status": {
                    "allOf": [
                        {
                            "$ref": "#/definitions/domain.TransferStatus"
                        }
                    ],
                    "example": "APPROVED"
                }
            }
        },
        "domain.WarehouseCreateRequest": {
            "type": "object",
            "required": [
                "name",
                "shop_id"
            ],
            "properties": {
                "is_active": {
                    "type": "boolean",
                    "example": true
                },
                "name": {
                    "type": "string",
                    "example": "Main Warehouse"
                },
                "shop_id": {
                    "type": "string",
                    "example": "550e8400-e29b-41d4-a716-446655440000"
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "description": "Type \"Bearer\" followed by a space and JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/api",
        Schemes:          []string{"http", "https"},
        Title:            "Warehouse Management API",
        Description:      "This is a comprehensive warehouse management system API for handling products, orders, warehouses, and transfers.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package domain

import (
        "context"
        "fmt"

        "github.com/nyaruka/phonenumbers"
)

// AuthLoginRequest represents the request payload for user authentication
type AuthLoginRequest struct {
        Identifier string `json:"identifier" validate:"required,identifier" example:"user@example.com" description:"Email address or phone number for login"`
        Password   string `json:"password" validate:"required,min=8" example:"password123" description:"User password (minimum 8 characters)"`
}

// AuthRegisterRequest represents the request payload for user registration
type AuthRegisterRequest struct {
        Email    string `json:"email" validate:"required,email" example:"user@example.com" description:"Valid email address"`
        Phone    string `json:"phone" validate:"required,phone" example:"+6281234567890" description:"Phone number with country code"`
        Password string `json:"password" validate:"required,min=8" example:"password123" description:"Password (minimum 8 characters)"`
}

func (u AuthRegisterRequest) MustFormattedPhone() string <span class="cov0" title="0">{
        phoneNumber, err := phonenumbers.Parse(u.Phone, "ID")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%d%d", phoneNumber.GetCountryCode(), phoneNumber.GetNationalNumber())</span>
}

type AuthUsecase interface {
        Register(ctx context.Context, payload AuthRegisterRequest) (User, error)
        Login(ctx context.Context, payload AuthLoginRequest) (string, error)
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package crypto

import (
        "github.com/dyaksa/encryption-pii/crypto"
        "github.com/dyaksa/encryption-pii/crypto/aesx"
        "github.com/dyaksa/encryption-pii/crypto/core"
)

type Crypto interface {
        AESFunc() func() (core.PrimitiveAES, error)
        Encrypt(data string) aesx.AES[string, core.PrimitiveAES]
        Decrypt(def string) aesx.AES[string, core.PrimitiveAES]
        BindHeap(entity any) error
        HashString(s string) string
}

type derivaleCrypto struct {
        c *crypto.Crypto
}

func (d *derivaleCrypto) Encrypt(data string) aesx.AES[string, core.PrimitiveAES] <span class="cov0" title="0">{
        return d.c.Encrypt(data, aesx.AesCBC)
}</span>

func (d *derivaleCrypto) BindHeap(entity any) error <span class="cov0" title="0">{
        return d.c.BindHeap(entity)
}</span>

func (d *derivaleCrypto) Decrypt(def string) aesx.AES[string, core.PrimitiveAES] <span class="cov0" title="0">{
        return aesx.AESChiper(d.c.AESFunc(), def, aesx.AesCBC)
}</span>

func (d *derivaleCrypto) AESFunc() func() (core.PrimitiveAES, error) <span class="cov0" title="0">{
        return d.c.AESFunc()
}</span>

func (d *derivaleCrypto) HashString(s string) string <span class="cov0" title="0">{
        return d.c.HashString(s)
}</span>

func New() (Crypto, error) <span class="cov0" title="0">{
        c, err := crypto.New(
                crypto.Aes256KeySize,
                crypto.WithInitHeapConnection(),
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;derivaleCrypto{c: c}, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package pqsql

import (
        "context"
        "database/sql"

        _ "github.com/lib/pq"
)

type database struct {
        db      *sql.DB
        wrapper *WrapperTx
}

func (d *database) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        return d.db.QueryRowContext(ctx, query, args...)
}</span>

func (d *database) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        return d.db.QueryContext(ctx, query, args...)
}</span>

func (d *database) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        return d.db.ExecContext(ctx, query, args...)
}</span>

type Database interface {
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
        QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
        ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        Transaction(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error)
}

func (d *database) Transaction(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error) <span class="cov0" title="0">{
        return d.wrapper.WrapTx(ctx, fn)
}</span>

type client struct {
        db *sql.DB
}

type Client interface {
        Database() Database
        PingContext(ctx context.Context) error
        BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)
        Begin() (*sql.Tx, error)
        PrepareContext(ctx context.Context, query string) (*sql.Stmt, error)
        Prepare(query string) (*sql.Stmt, error)
        Close() error
        Ping() error
}

func (c *client) Database() Database <span class="cov0" title="0">{
        return &amp;database{db: c.db, wrapper: NewWrapper(c.db)}
}</span>

func (c *client) PingContext(ctx context.Context) error <span class="cov0" title="0">{
        return c.db.PingContext(ctx)
}</span>

func (c *client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        return c.db.BeginTx(ctx, opts)
}</span>

func (c *client) Begin() (*sql.Tx, error) <span class="cov0" title="0">{
        return c.db.Begin()
}</span>

func (c *client) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return c.db.PrepareContext(ctx, query)
}</span>

func (c *client) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return c.db.Prepare(query)
}</span>

func (c *client) Close() error <span class="cov0" title="0">{
        return c.db.Close()
}</span>

func (c *client) Ping() error <span class="cov0" title="0">{
        return c.db.Ping()
}</span>

func NewClient(connection string) (Client, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", connection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client := &amp;client{db: db}

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package pqsql

import (
        "context"
        "database/sql"
)

type WrapperTx struct {
        db *sql.DB
}

func NewWrapper(db *sql.DB) *WrapperTx <span class="cov0" title="0">{
        return &amp;WrapperTx{
                db: db,
        }
}</span>

func (w *WrapperTx) WrapTx(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error) <span class="cov0" title="0">{
        tx, err := w.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">res, err := fn(ctx, tx)
        switch err </span>{
        case nil:<span class="cov0" title="0"></span>
        case sql.ErrNoRows:<span class="cov0" title="0">
                return res, nil</span>
        default:<span class="cov0" title="0">
                _ = tx.Rollback()
                return nil, err</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/dyaksa/warehouse/api/middleware"
        "github.com/dyaksa/warehouse/api/route"
        "github.com/dyaksa/warehouse/api/worker"
        "github.com/dyaksa/warehouse/bootstrap"
        _ "github.com/dyaksa/warehouse/docs" // Swagger docs
        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/dyaksa/warehouse/repository"
        "github.com/dyaksa/warehouse/usecase"
        "github.com/gin-contrib/cors"
)

// @title Warehouse Management API
// @version 1.0
// @description This is a comprehensive warehouse management system API for handling products, orders, warehouses, and transfers.
// @termsOfService http://swagger.io/terms/

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT

// @host localhost:8080
// @BasePath /api

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token.

// @schemes http https
// @produce json
// @consumes json

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        app := bootstrap.App(ctx)

        defer app.CloseConnection()

        env := app.Env
        router := app.App
        l := app.Log
        db := app.Postgres
        crypto := app.Crypto

        router.Use(cors.Default())
        router.Use(middleware.RateLimitMiddleware(time.Second, 100, "api"))

        timeout := time.Duration(env.ContextTimeout) * time.Second

        reservationRepo := repository.NewReservationRepository(db)
        productStockRepo := repository.NewProductStockRepository(db)
        movementRepo := repository.NewMovementRepository(db)
        orderRepo := repository.NewOrderRepository(db)

        // Initialize stock release usecase
        stockReleaseUsecase := usecase.NewStockReleaseUsecase(
                db.Database(),
                reservationRepo,
                productStockRepo,
                movementRepo,
                orderRepo,
        )

        workerConfig := worker.StockReleaseWorkerConfig{
                BatchSize: 50,
                Interval:  30 * time.Second,
        }

        stockReleaseWorker := worker.NewStockReleaseWorker(stockReleaseUsecase, workerConfig)

        // Create context for worker with cancellation
        workerCtx, workerCancel := context.WithCancel(ctx)
        defer workerCancel()

        // Start the stock release worker in a goroutine
        go func() </span><span class="cov0" title="0">{
                l.Info("Starting stock release worker...")
                stockReleaseWorker.Start(workerCtx)
        }</span>()

        <span class="cov0" title="0">route.Setup(env, timeout, db, l, crypto, router)

        route.NewStockReleaseRoute(env, timeout, db, l, crypto, router, stockReleaseWorker)

        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%s", env.Port),
                Handler: app.App.Handler(),
        }

        go func() </span><span class="cov0" title="0">{
                l.Info(fmt.Sprintf("%s is running on port %s", env.AppName, env.Port))
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        l.Error("failed to start server", log.Error("error", err))
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        l.Info("shutting down server")

        l.Info("stopping stock release worker")
        workerCancel() // Cancel the worker context
        stockReleaseWorker.Stop()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                l.Fatal("server forced to shutdown", log.Error("error", err))
        }</span>

        <span class="cov0" title="0">l.Info("server stopped")</span>

}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package crypto

import (
        "github.com/dyaksa/encryption-pii/crypto/aesx"
        "github.com/dyaksa/encryption-pii/crypto/core"
        mock "github.com/stretchr/testify/mock"
)

// NewMockCrypto creates a new instance of MockCrypto. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCrypto(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockCrypto <span class="cov0" title="0">{
        mock := &amp;MockCrypto{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockCrypto is an autogenerated mock type for the Crypto type
type MockCrypto struct {
        mock.Mock
}

type MockCrypto_Expecter struct {
        mock *mock.Mock
}

func (_m *MockCrypto) EXPECT() *MockCrypto_Expecter <span class="cov0" title="0">{
        return &amp;MockCrypto_Expecter{mock: &amp;_m.Mock}
}</span>

// AESFunc provides a mock function for the type MockCrypto
func (_mock *MockCrypto) AESFunc() func() (core.PrimitiveAES, error) <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AESFunc")</span>
        }

        <span class="cov0" title="0">var r0 func() (core.PrimitiveAES, error)
        if returnFunc, ok := ret.Get(0).(func() func() (core.PrimitiveAES, error)); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(func() (core.PrimitiveAES, error))
                }</span>
        }
        <span class="cov0" title="0">return r0</span>
}

// MockCrypto_AESFunc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AESFunc'
type MockCrypto_AESFunc_Call struct {
        *mock.Call
}

// AESFunc is a helper method to define mock.On call
func (_e *MockCrypto_Expecter) AESFunc() *MockCrypto_AESFunc_Call <span class="cov0" title="0">{
        return &amp;MockCrypto_AESFunc_Call{Call: _e.mock.On("AESFunc")}
}</span>

func (_c *MockCrypto_AESFunc_Call) Run(run func()) *MockCrypto_AESFunc_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCrypto_AESFunc_Call) Return(fn func() (core.PrimitiveAES, error)) *MockCrypto_AESFunc_Call <span class="cov0" title="0">{
        _c.Call.Return(fn)
        return _c
}</span>

func (_c *MockCrypto_AESFunc_Call) RunAndReturn(run func() func() (core.PrimitiveAES, error)) *MockCrypto_AESFunc_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// BindHeap provides a mock function for the type MockCrypto
func (_mock *MockCrypto) BindHeap(entity any) error <span class="cov0" title="0">{
        ret := _mock.Called(entity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BindHeap")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(any) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(entity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockCrypto_BindHeap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BindHeap'
type MockCrypto_BindHeap_Call struct {
        *mock.Call
}

// BindHeap is a helper method to define mock.On call
//   - entity
func (_e *MockCrypto_Expecter) BindHeap(entity interface{}) *MockCrypto_BindHeap_Call <span class="cov0" title="0">{
        return &amp;MockCrypto_BindHeap_Call{Call: _e.mock.On("BindHeap", entity)}
}</span>

func (_c *MockCrypto_BindHeap_Call) Run(run func(entity any)) *MockCrypto_BindHeap_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(any))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCrypto_BindHeap_Call) Return(err error) *MockCrypto_BindHeap_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockCrypto_BindHeap_Call) RunAndReturn(run func(entity any) error) *MockCrypto_BindHeap_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Decrypt provides a mock function for the type MockCrypto
func (_mock *MockCrypto) Decrypt(def string) aesx.AES[string, core.PrimitiveAES] <span class="cov0" title="0">{
        ret := _mock.Called(def)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Decrypt")</span>
        }

        <span class="cov0" title="0">var r0 aesx.AES[string, core.PrimitiveAES]
        if returnFunc, ok := ret.Get(0).(func(string) aesx.AES[string, core.PrimitiveAES]); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(def)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(aesx.AES[string, core.PrimitiveAES])
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockCrypto_Decrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decrypt'
type MockCrypto_Decrypt_Call struct {
        *mock.Call
}

// Decrypt is a helper method to define mock.On call
//   - def
func (_e *MockCrypto_Expecter) Decrypt(def interface{}) *MockCrypto_Decrypt_Call <span class="cov0" title="0">{
        return &amp;MockCrypto_Decrypt_Call{Call: _e.mock.On("Decrypt", def)}
}</span>

func (_c *MockCrypto_Decrypt_Call) Run(run func(def string)) *MockCrypto_Decrypt_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCrypto_Decrypt_Call) Return(aES aesx.AES[string, core.PrimitiveAES]) *MockCrypto_Decrypt_Call <span class="cov0" title="0">{
        _c.Call.Return(aES)
        return _c
}</span>

func (_c *MockCrypto_Decrypt_Call) RunAndReturn(run func(def string) aesx.AES[string, core.PrimitiveAES]) *MockCrypto_Decrypt_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Encrypt provides a mock function for the type MockCrypto
func (_mock *MockCrypto) Encrypt(data string) aesx.AES[string, core.PrimitiveAES] <span class="cov0" title="0">{
        ret := _mock.Called(data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Encrypt")</span>
        }

        <span class="cov0" title="0">var r0 aesx.AES[string, core.PrimitiveAES]
        if returnFunc, ok := ret.Get(0).(func(string) aesx.AES[string, core.PrimitiveAES]); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(data)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(aesx.AES[string, core.PrimitiveAES])
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockCrypto_Encrypt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Encrypt'
type MockCrypto_Encrypt_Call struct {
        *mock.Call
}

// Encrypt is a helper method to define mock.On call
//   - data
func (_e *MockCrypto_Expecter) Encrypt(data interface{}) *MockCrypto_Encrypt_Call <span class="cov0" title="0">{
        return &amp;MockCrypto_Encrypt_Call{Call: _e.mock.On("Encrypt", data)}
}</span>

func (_c *MockCrypto_Encrypt_Call) Run(run func(data string)) *MockCrypto_Encrypt_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCrypto_Encrypt_Call) Return(aES aesx.AES[string, core.PrimitiveAES]) *MockCrypto_Encrypt_Call <span class="cov0" title="0">{
        _c.Call.Return(aES)
        return _c
}</span>

func (_c *MockCrypto_Encrypt_Call) RunAndReturn(run func(data string) aesx.AES[string, core.PrimitiveAES]) *MockCrypto_Encrypt_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// HashString provides a mock function for the type MockCrypto
func (_mock *MockCrypto) HashString(s string) string <span class="cov0" title="0">{
        ret := _mock.Called(s)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for HashString")</span>
        }

        <span class="cov0" title="0">var r0 string
        if returnFunc, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(s)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockCrypto_HashString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashString'
type MockCrypto_HashString_Call struct {
        *mock.Call
}

// HashString is a helper method to define mock.On call
//   - s
func (_e *MockCrypto_Expecter) HashString(s interface{}) *MockCrypto_HashString_Call <span class="cov0" title="0">{
        return &amp;MockCrypto_HashString_Call{Call: _e.mock.On("HashString", s)}
}</span>

func (_c *MockCrypto_HashString_Call) Run(run func(s string)) *MockCrypto_HashString_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCrypto_HashString_Call) Return(s1 string) *MockCrypto_HashString_Call <span class="cov0" title="0">{
        _c.Call.Return(s1)
        return _c
}</span>

func (_c *MockCrypto_HashString_Call) RunAndReturn(run func(s string) string) *MockCrypto_HashString_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package pqsql

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        mock "github.com/stretchr/testify/mock"
)

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockClient <span class="cov0" title="0">{
        mock := &amp;MockClient{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
        mock.Mock
}

type MockClient_Expecter struct {
        mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter <span class="cov0" title="0">{
        return &amp;MockClient_Expecter{mock: &amp;_m.Mock}
}</span>

// Begin provides a mock function for the type MockClient
func (_mock *MockClient) Begin() (*sql.Tx, error) <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Begin")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Tx
        var r1 error
        if returnFunc, ok := ret.Get(0).(func() (*sql.Tx, error)); ok </span><span class="cov0" title="0">{
                return returnFunc()
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func() *sql.Tx); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Tx)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockClient_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type MockClient_Begin_Call struct {
        *mock.Call
}

// Begin is a helper method to define mock.On call
func (_e *MockClient_Expecter) Begin() *MockClient_Begin_Call <span class="cov0" title="0">{
        return &amp;MockClient_Begin_Call{Call: _e.mock.On("Begin")}
}</span>

func (_c *MockClient_Begin_Call) Run(run func()) *MockClient_Begin_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_Begin_Call) Return(tx *sql.Tx, err error) *MockClient_Begin_Call <span class="cov0" title="0">{
        _c.Call.Return(tx, err)
        return _c
}</span>

func (_c *MockClient_Begin_Call) RunAndReturn(run func() (*sql.Tx, error)) *MockClient_Begin_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// BeginTx provides a mock function for the type MockClient
func (_mock *MockClient) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, opts)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginTx")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Tx
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.TxOptions) (*sql.Tx, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, opts)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.TxOptions) *sql.Tx); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, opts)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Tx)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.TxOptions) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, opts)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockClient_BeginTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTx'
type MockClient_BeginTx_Call struct {
        *mock.Call
}

// BeginTx is a helper method to define mock.On call
//   - ctx
//   - opts
func (_e *MockClient_Expecter) BeginTx(ctx interface{}, opts interface{}) *MockClient_BeginTx_Call <span class="cov0" title="0">{
        return &amp;MockClient_BeginTx_Call{Call: _e.mock.On("BeginTx", ctx, opts)}
}</span>

func (_c *MockClient_BeginTx_Call) Run(run func(ctx context.Context, opts *sql.TxOptions)) *MockClient_BeginTx_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.TxOptions))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_BeginTx_Call) Return(tx *sql.Tx, err error) *MockClient_BeginTx_Call <span class="cov0" title="0">{
        _c.Call.Return(tx, err)
        return _c
}</span>

func (_c *MockClient_BeginTx_Call) RunAndReturn(run func(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)) *MockClient_BeginTx_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Close provides a mock function for the type MockClient
func (_mock *MockClient) Close() error <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockClient_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockClient_Close_Call struct {
        *mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockClient_Expecter) Close() *MockClient_Close_Call <span class="cov0" title="0">{
        return &amp;MockClient_Close_Call{Call: _e.mock.On("Close")}
}</span>

func (_c *MockClient_Close_Call) Run(run func()) *MockClient_Close_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_Close_Call) Return(err error) *MockClient_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockClient_Close_Call) RunAndReturn(run func() error) *MockClient_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Database provides a mock function for the type MockClient
func (_mock *MockClient) Database() pqsql.Database <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Database")</span>
        }

        <span class="cov0" title="0">var r0 pqsql.Database
        if returnFunc, ok := ret.Get(0).(func() pqsql.Database); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(pqsql.Database)
                }</span>
        }
        <span class="cov0" title="0">return r0</span>
}

// MockClient_Database_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Database'
type MockClient_Database_Call struct {
        *mock.Call
}

// Database is a helper method to define mock.On call
func (_e *MockClient_Expecter) Database() *MockClient_Database_Call <span class="cov0" title="0">{
        return &amp;MockClient_Database_Call{Call: _e.mock.On("Database")}
}</span>

func (_c *MockClient_Database_Call) Run(run func()) *MockClient_Database_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_Database_Call) Return(database pqsql.Database) *MockClient_Database_Call <span class="cov0" title="0">{
        _c.Call.Return(database)
        return _c
}</span>

func (_c *MockClient_Database_Call) RunAndReturn(run func() pqsql.Database) *MockClient_Database_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Ping provides a mock function for the type MockClient
func (_mock *MockClient) Ping() error <span class="cov0" title="0">{
        ret := _mock.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Ping")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockClient_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockClient_Ping_Call struct {
        *mock.Call
}

// Ping is a helper method to define mock.On call
func (_e *MockClient_Expecter) Ping() *MockClient_Ping_Call <span class="cov0" title="0">{
        return &amp;MockClient_Ping_Call{Call: _e.mock.On("Ping")}
}</span>

func (_c *MockClient_Ping_Call) Run(run func()) *MockClient_Ping_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_Ping_Call) Return(err error) *MockClient_Ping_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockClient_Ping_Call) RunAndReturn(run func() error) *MockClient_Ping_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// PingContext provides a mock function for the type MockClient
func (_mock *MockClient) PingContext(ctx context.Context) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PingContext")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockClient_PingContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PingContext'
type MockClient_PingContext_Call struct {
        *mock.Call
}

// PingContext is a helper method to define mock.On call
//   - ctx
func (_e *MockClient_Expecter) PingContext(ctx interface{}) *MockClient_PingContext_Call <span class="cov0" title="0">{
        return &amp;MockClient_PingContext_Call{Call: _e.mock.On("PingContext", ctx)}
}</span>

func (_c *MockClient_PingContext_Call) Run(run func(ctx context.Context)) *MockClient_PingContext_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_PingContext_Call) Return(err error) *MockClient_PingContext_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockClient_PingContext_Call) RunAndReturn(run func(ctx context.Context) error) *MockClient_PingContext_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Prepare provides a mock function for the type MockClient
func (_mock *MockClient) Prepare(query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _mock.Called(query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Prepare")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(query)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockClient_Prepare_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Prepare'
type MockClient_Prepare_Call struct {
        *mock.Call
}

// Prepare is a helper method to define mock.On call
//   - query
func (_e *MockClient_Expecter) Prepare(query interface{}) *MockClient_Prepare_Call <span class="cov0" title="0">{
        return &amp;MockClient_Prepare_Call{Call: _e.mock.On("Prepare", query)}
}</span>

func (_c *MockClient_Prepare_Call) Run(run func(query string)) *MockClient_Prepare_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_Prepare_Call) Return(stmt *sql.Stmt, err error) *MockClient_Prepare_Call <span class="cov0" title="0">{
        _c.Call.Return(stmt, err)
        return _c
}</span>

func (_c *MockClient_Prepare_Call) RunAndReturn(run func(query string) (*sql.Stmt, error)) *MockClient_Prepare_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// PrepareContext provides a mock function for the type MockClient
func (_mock *MockClient) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, query)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PrepareContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Stmt
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*sql.Stmt, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, query)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string) *sql.Stmt); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Stmt)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, query)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockClient_PrepareContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PrepareContext'
type MockClient_PrepareContext_Call struct {
        *mock.Call
}

// PrepareContext is a helper method to define mock.On call
//   - ctx
//   - query
func (_e *MockClient_Expecter) PrepareContext(ctx interface{}, query interface{}) *MockClient_PrepareContext_Call <span class="cov0" title="0">{
        return &amp;MockClient_PrepareContext_Call{Call: _e.mock.On("PrepareContext", ctx, query)}
}</span>

func (_c *MockClient_PrepareContext_Call) Run(run func(ctx context.Context, query string)) *MockClient_PrepareContext_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockClient_PrepareContext_Call) Return(stmt *sql.Stmt, err error) *MockClient_PrepareContext_Call <span class="cov0" title="0">{
        _c.Call.Return(stmt, err)
        return _c
}</span>

func (_c *MockClient_PrepareContext_Call) RunAndReturn(run func(ctx context.Context, query string) (*sql.Stmt, error)) *MockClient_PrepareContext_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package pqsql

import (
        "context"
        "database/sql"

        mock "github.com/stretchr/testify/mock"
)

// NewMockDatabase creates a new instance of MockDatabase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDatabase(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockDatabase <span class="cov0" title="0">{
        mock := &amp;MockDatabase{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockDatabase is an autogenerated mock type for the Database type
type MockDatabase struct {
        mock.Mock
}

type MockDatabase_Expecter struct {
        mock *mock.Mock
}

func (_m *MockDatabase) EXPECT() *MockDatabase_Expecter <span class="cov0" title="0">{
        return &amp;MockDatabase_Expecter{mock: &amp;_m.Mock}
}</span>

// ExecContext provides a mock function for the type MockDatabase
func (_mock *MockDatabase) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        var tmpRet mock.Arguments
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                tmpRet = _mock.Called(ctx, query, args)
        }</span> else<span class="cov0" title="0"> {
                tmpRet = _mock.Called(ctx, query)
        }</span>
        <span class="cov0" title="0">ret := tmpRet

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ExecContext")</span>
        }

        <span class="cov0" title="0">var r0 sql.Result
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (sql.Result, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...interface{}) sql.Result); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(sql.Result)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockDatabase_ExecContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecContext'
type MockDatabase_ExecContext_Call struct {
        *mock.Call
}

// ExecContext is a helper method to define mock.On call
//   - ctx
//   - query
//   - args
func (_e *MockDatabase_Expecter) ExecContext(ctx interface{}, query interface{}, args ...interface{}) *MockDatabase_ExecContext_Call <span class="cov0" title="0">{
        return &amp;MockDatabase_ExecContext_Call{Call: _e.mock.On("ExecContext",
                append([]interface{}{ctx, query}, args...)...)}
}</span>

func (_c *MockDatabase_ExecContext_Call) Run(run func(ctx context.Context, query string, args ...interface{})) *MockDatabase_ExecContext_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := args[2].([]interface{})
                run(args[0].(context.Context), args[1].(string), variadicArgs...)
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDatabase_ExecContext_Call) Return(result sql.Result, err error) *MockDatabase_ExecContext_Call <span class="cov0" title="0">{
        _c.Call.Return(result, err)
        return _c
}</span>

func (_c *MockDatabase_ExecContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...interface{}) (sql.Result, error)) *MockDatabase_ExecContext_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// QueryContext provides a mock function for the type MockDatabase
func (_mock *MockDatabase) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        var tmpRet mock.Arguments
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                tmpRet = _mock.Called(ctx, query, args)
        }</span> else<span class="cov0" title="0"> {
                tmpRet = _mock.Called(ctx, query)
        }</span>
        <span class="cov0" title="0">ret := tmpRet

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Rows
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...interface{}) (*sql.Rows, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, query, args...)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Rows); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Rows)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string, ...interface{}) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockDatabase_QueryContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryContext'
type MockDatabase_QueryContext_Call struct {
        *mock.Call
}

// QueryContext is a helper method to define mock.On call
//   - ctx
//   - query
//   - args
func (_e *MockDatabase_Expecter) QueryContext(ctx interface{}, query interface{}, args ...interface{}) *MockDatabase_QueryContext_Call <span class="cov0" title="0">{
        return &amp;MockDatabase_QueryContext_Call{Call: _e.mock.On("QueryContext",
                append([]interface{}{ctx, query}, args...)...)}
}</span>

func (_c *MockDatabase_QueryContext_Call) Run(run func(ctx context.Context, query string, args ...interface{})) *MockDatabase_QueryContext_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := args[2].([]interface{})
                run(args[0].(context.Context), args[1].(string), variadicArgs...)
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDatabase_QueryContext_Call) Return(rows *sql.Rows, err error) *MockDatabase_QueryContext_Call <span class="cov0" title="0">{
        _c.Call.Return(rows, err)
        return _c
}</span>

func (_c *MockDatabase_QueryContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)) *MockDatabase_QueryContext_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// QueryRowContext provides a mock function for the type MockDatabase
func (_mock *MockDatabase) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        var tmpRet mock.Arguments
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                tmpRet = _mock.Called(ctx, query, args)
        }</span> else<span class="cov0" title="0"> {
                tmpRet = _mock.Called(ctx, query)
        }</span>
        <span class="cov0" title="0">ret := tmpRet

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for QueryRowContext")</span>
        }

        <span class="cov0" title="0">var r0 *sql.Row
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *sql.Row); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, query, args...)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*sql.Row)
                }</span>
        }
        <span class="cov0" title="0">return r0</span>
}

// MockDatabase_QueryRowContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'QueryRowContext'
type MockDatabase_QueryRowContext_Call struct {
        *mock.Call
}

// QueryRowContext is a helper method to define mock.On call
//   - ctx
//   - query
//   - args
func (_e *MockDatabase_Expecter) QueryRowContext(ctx interface{}, query interface{}, args ...interface{}) *MockDatabase_QueryRowContext_Call <span class="cov0" title="0">{
        return &amp;MockDatabase_QueryRowContext_Call{Call: _e.mock.On("QueryRowContext",
                append([]interface{}{ctx, query}, args...)...)}
}</span>

func (_c *MockDatabase_QueryRowContext_Call) Run(run func(ctx context.Context, query string, args ...interface{})) *MockDatabase_QueryRowContext_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                variadicArgs := args[2].([]interface{})
                run(args[0].(context.Context), args[1].(string), variadicArgs...)
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDatabase_QueryRowContext_Call) Return(row *sql.Row) *MockDatabase_QueryRowContext_Call <span class="cov0" title="0">{
        _c.Call.Return(row)
        return _c
}</span>

func (_c *MockDatabase_QueryRowContext_Call) RunAndReturn(run func(ctx context.Context, query string, args ...interface{}) *sql.Row) *MockDatabase_QueryRowContext_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Transaction provides a mock function for the type MockDatabase
func (_mock *MockDatabase) Transaction(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, fn)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Transaction")</span>
        }

        <span class="cov0" title="0">var r0 any
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, fn)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, func(ctx context.Context, tx *sql.Tx) (any, error)) any); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, fn)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(any)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, func(ctx context.Context, tx *sql.Tx) (any, error)) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, fn)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockDatabase_Transaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transaction'
type MockDatabase_Transaction_Call struct {
        *mock.Call
}

// Transaction is a helper method to define mock.On call
//   - ctx
//   - fn
func (_e *MockDatabase_Expecter) Transaction(ctx interface{}, fn interface{}) *MockDatabase_Transaction_Call <span class="cov0" title="0">{
        return &amp;MockDatabase_Transaction_Call{Call: _e.mock.On("Transaction", ctx, fn)}
}</span>

func (_c *MockDatabase_Transaction_Call) Run(run func(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error))) *MockDatabase_Transaction_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(func(ctx context.Context, tx *sql.Tx) (any, error)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDatabase_Transaction_Call) Return(v any, err error) *MockDatabase_Transaction_Call <span class="cov0" title="0">{
        _c.Call.Return(v, err)
        return _c
}</span>

func (_c *MockDatabase_Transaction_Call) RunAndReturn(run func(ctx context.Context, fn func(ctx context.Context, tx *sql.Tx) (any, error)) (any, error)) *MockDatabase_Transaction_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockIdempotencyRequestRepository creates a new instance of MockIdempotencyRequestRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIdempotencyRequestRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockIdempotencyRequestRepository <span class="cov0" title="0">{
        mock := &amp;MockIdempotencyRequestRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockIdempotencyRequestRepository is an autogenerated mock type for the IdempotencyRequestRepository type
type MockIdempotencyRequestRepository struct {
        mock.Mock
}

type MockIdempotencyRequestRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockIdempotencyRequestRepository) EXPECT() *MockIdempotencyRequestRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockIdempotencyRequestRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// BeginKey provides a mock function for the type MockIdempotencyRequestRepository
func (_mock *MockIdempotencyRequestRepository) BeginKey(ctx context.Context, tx *sql.Tx, key string, endpoint string, payloadHash string) (bool, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, key, endpoint, payloadHash)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BeginKey")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, string, string, string) (bool, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, key, endpoint, payloadHash)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, string, string, string) bool); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, key, endpoint, payloadHash)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, string, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, key, endpoint, payloadHash)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockIdempotencyRequestRepository_BeginKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginKey'
type MockIdempotencyRequestRepository_BeginKey_Call struct {
        *mock.Call
}

// BeginKey is a helper method to define mock.On call
//   - ctx
//   - tx
//   - key
//   - endpoint
//   - payloadHash
func (_e *MockIdempotencyRequestRepository_Expecter) BeginKey(ctx interface{}, tx interface{}, key interface{}, endpoint interface{}, payloadHash interface{}) *MockIdempotencyRequestRepository_BeginKey_Call <span class="cov0" title="0">{
        return &amp;MockIdempotencyRequestRepository_BeginKey_Call{Call: _e.mock.On("BeginKey", ctx, tx, key, endpoint, payloadHash)}
}</span>

func (_c *MockIdempotencyRequestRepository_BeginKey_Call) Run(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string, payloadHash string)) *MockIdempotencyRequestRepository_BeginKey_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(string), args[3].(string), args[4].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockIdempotencyRequestRepository_BeginKey_Call) Return(isNew bool, err error) *MockIdempotencyRequestRepository_BeginKey_Call <span class="cov0" title="0">{
        _c.Call.Return(isNew, err)
        return _c
}</span>

func (_c *MockIdempotencyRequestRepository_BeginKey_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string, payloadHash string) (bool, error)) *MockIdempotencyRequestRepository_BeginKey_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// LoadIfExists provides a mock function for the type MockIdempotencyRequestRepository
func (_mock *MockIdempotencyRequestRepository) LoadIfExists(ctx context.Context, tx *sql.Tx, key string, endpoint string) (string, *uuid.UUID, []byte, bool, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, key, endpoint)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for LoadIfExists")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 *uuid.UUID
        var r2 []byte
        var r3 bool
        var r4 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, string, string) (string, *uuid.UUID, []byte, bool, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, key, endpoint)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, key, endpoint)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, string, string) *uuid.UUID); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, key, endpoint)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(1) != nil </span><span class="cov0" title="0">{
                        r1 = ret.Get(1).(*uuid.UUID)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(2).(func(context.Context, *sql.Tx, string, string) []byte); ok </span><span class="cov0" title="0">{
                r2 = returnFunc(ctx, tx, key, endpoint)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(2) != nil </span><span class="cov0" title="0">{
                        r2 = ret.Get(2).([]byte)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(3).(func(context.Context, *sql.Tx, string, string) bool); ok </span><span class="cov0" title="0">{
                r3 = returnFunc(ctx, tx, key, endpoint)
        }</span> else<span class="cov0" title="0"> {
                r3 = ret.Get(3).(bool)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(4).(func(context.Context, *sql.Tx, string, string) error); ok </span><span class="cov0" title="0">{
                r4 = returnFunc(ctx, tx, key, endpoint)
        }</span> else<span class="cov0" title="0"> {
                r4 = ret.Error(4)
        }</span>
        <span class="cov0" title="0">return r0, r1, r2, r3, r4</span>
}

// MockIdempotencyRequestRepository_LoadIfExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadIfExists'
type MockIdempotencyRequestRepository_LoadIfExists_Call struct {
        *mock.Call
}

// LoadIfExists is a helper method to define mock.On call
//   - ctx
//   - tx
//   - key
//   - endpoint
func (_e *MockIdempotencyRequestRepository_Expecter) LoadIfExists(ctx interface{}, tx interface{}, key interface{}, endpoint interface{}) *MockIdempotencyRequestRepository_LoadIfExists_Call <span class="cov0" title="0">{
        return &amp;MockIdempotencyRequestRepository_LoadIfExists_Call{Call: _e.mock.On("LoadIfExists", ctx, tx, key, endpoint)}
}</span>

func (_c *MockIdempotencyRequestRepository_LoadIfExists_Call) Run(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string)) *MockIdempotencyRequestRepository_LoadIfExists_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(string), args[3].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockIdempotencyRequestRepository_LoadIfExists_Call) Return(payloadHash string, orderID *uuid.UUID, responseJSON []byte, exists bool, err error) *MockIdempotencyRequestRepository_LoadIfExists_Call <span class="cov0" title="0">{
        _c.Call.Return(payloadHash, orderID, responseJSON, exists, err)
        return _c
}</span>

func (_c *MockIdempotencyRequestRepository_LoadIfExists_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string) (string, *uuid.UUID, []byte, bool, error)) *MockIdempotencyRequestRepository_LoadIfExists_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SaveResponse provides a mock function for the type MockIdempotencyRequestRepository
func (_mock *MockIdempotencyRequestRepository) SaveResponse(ctx context.Context, tx *sql.Tx, key string, endpoint string, orderID uuid.UUID, responseJSON []byte) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, key, endpoint, orderID, responseJSON)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveResponse")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, string, string, uuid.UUID, []byte) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, key, endpoint, orderID, responseJSON)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockIdempotencyRequestRepository_SaveResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveResponse'
type MockIdempotencyRequestRepository_SaveResponse_Call struct {
        *mock.Call
}

// SaveResponse is a helper method to define mock.On call
//   - ctx
//   - tx
//   - key
//   - endpoint
//   - orderID
//   - responseJSON
func (_e *MockIdempotencyRequestRepository_Expecter) SaveResponse(ctx interface{}, tx interface{}, key interface{}, endpoint interface{}, orderID interface{}, responseJSON interface{}) *MockIdempotencyRequestRepository_SaveResponse_Call <span class="cov0" title="0">{
        return &amp;MockIdempotencyRequestRepository_SaveResponse_Call{Call: _e.mock.On("SaveResponse", ctx, tx, key, endpoint, orderID, responseJSON)}
}</span>

func (_c *MockIdempotencyRequestRepository_SaveResponse_Call) Run(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string, orderID uuid.UUID, responseJSON []byte)) *MockIdempotencyRequestRepository_SaveResponse_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(string), args[3].(string), args[4].(uuid.UUID), args[5].([]byte))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockIdempotencyRequestRepository_SaveResponse_Call) Return(err error) *MockIdempotencyRequestRepository_SaveResponse_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockIdempotencyRequestRepository_SaveResponse_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, key string, endpoint string, orderID uuid.UUID, responseJSON []byte) error) *MockIdempotencyRequestRepository_SaveResponse_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockMovementRepository creates a new instance of MockMovementRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMovementRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockMovementRepository <span class="cov0" title="0">{
        mock := &amp;MockMovementRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockMovementRepository is an autogenerated mock type for the MovementRepository type
type MockMovementRepository struct {
        mock.Mock
}

type MockMovementRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockMovementRepository) EXPECT() *MockMovementRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockMovementRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Append provides a mock function for the type MockMovementRepository
func (_mock *MockMovementRepository) Append(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, typ string, qty int, refType string, refID uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, warehouseID, typ, qty, refType, refID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Append")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, string, int, string, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, warehouseID, typ, qty, refType, refID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockMovementRepository_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type MockMovementRepository_Append_Call struct {
        *mock.Call
}

// Append is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - warehouseID
//   - typ
//   - qty
//   - refType
//   - refID
func (_e *MockMovementRepository_Expecter) Append(ctx interface{}, tx interface{}, productID interface{}, warehouseID interface{}, typ interface{}, qty interface{}, refType interface{}, refID interface{}) *MockMovementRepository_Append_Call <span class="cov0" title="0">{
        return &amp;MockMovementRepository_Append_Call{Call: _e.mock.On("Append", ctx, tx, productID, warehouseID, typ, qty, refType, refID)}
}</span>

func (_c *MockMovementRepository_Append_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, typ string, qty int, refType string, refID uuid.UUID)) *MockMovementRepository_Append_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(string), args[5].(int), args[6].(string), args[7].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockMovementRepository_Append_Call) Return(err error) *MockMovementRepository_Append_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockMovementRepository_Append_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, typ string, qty int, refType string, refID uuid.UUID) error) *MockMovementRepository_Append_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        mock "github.com/stretchr/testify/mock"
)

// NewMockOrderItemRepository creates a new instance of MockOrderItemRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOrderItemRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockOrderItemRepository <span class="cov0" title="0">{
        mock := &amp;MockOrderItemRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockOrderItemRepository is an autogenerated mock type for the OrderItemRepository type
type MockOrderItemRepository struct {
        mock.Mock
}

type MockOrderItemRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockOrderItemRepository) EXPECT() *MockOrderItemRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockOrderItemRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// BulkInsert provides a mock function for the type MockOrderItemRepository
func (_mock *MockOrderItemRepository) BulkInsert(ctx context.Context, tx *sql.Tx, items []domain.OrderItem) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, items)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BulkInsert")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, []domain.OrderItem) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, items)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockOrderItemRepository_BulkInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkInsert'
type MockOrderItemRepository_BulkInsert_Call struct {
        *mock.Call
}

// BulkInsert is a helper method to define mock.On call
//   - ctx
//   - tx
//   - items
func (_e *MockOrderItemRepository_Expecter) BulkInsert(ctx interface{}, tx interface{}, items interface{}) *MockOrderItemRepository_BulkInsert_Call <span class="cov0" title="0">{
        return &amp;MockOrderItemRepository_BulkInsert_Call{Call: _e.mock.On("BulkInsert", ctx, tx, items)}
}</span>

func (_c *MockOrderItemRepository_BulkInsert_Call) Run(run func(ctx context.Context, tx *sql.Tx, items []domain.OrderItem)) *MockOrderItemRepository_BulkInsert_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].([]domain.OrderItem))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderItemRepository_BulkInsert_Call) Return(err error) *MockOrderItemRepository_BulkInsert_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockOrderItemRepository_BulkInsert_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, items []domain.OrderItem) error) *MockOrderItemRepository_BulkInsert_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockOrderRepository creates a new instance of MockOrderRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOrderRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockOrderRepository <span class="cov0" title="0">{
        mock := &amp;MockOrderRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockOrderRepository is an autogenerated mock type for the OrderRepository type
type MockOrderRepository struct {
        mock.Mock
}

type MockOrderRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockOrderRepository) EXPECT() *MockOrderRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockOrderRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Create(ctx context.Context, tx *sql.Tx, o *domain.Order) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, o)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, *domain.Order) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, o)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockOrderRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - tx
//   - o
func (_e *MockOrderRepository_Expecter) Create(ctx interface{}, tx interface{}, o interface{}) *MockOrderRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepository_Create_Call{Call: _e.mock.On("Create", ctx, tx, o)}
}</span>

func (_c *MockOrderRepository_Create_Call) Run(run func(ctx context.Context, tx *sql.Tx, o *domain.Order)) *MockOrderRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(*domain.Order))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepository_Create_Call) Return(err error) *MockOrderRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockOrderRepository_Create_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, o *domain.Order) error) *MockOrderRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetByID(ctx context.Context, orderID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, orderID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *domain.Order
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Order, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, orderID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Order); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, orderID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.Order)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockOrderRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockOrderRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx
//   - orderID
func (_e *MockOrderRepository_Expecter) GetByID(ctx interface{}, orderID interface{}) *MockOrderRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, orderID)}
}</span>

func (_c *MockOrderRepository_GetByID_Call) Run(run func(ctx context.Context, orderID uuid.UUID)) *MockOrderRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepository_GetByID_Call) Return(order *domain.Order, err error) *MockOrderRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(order, err)
        return _c
}</span>

func (_c *MockOrderRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, orderID uuid.UUID) (*domain.Order, error)) *MockOrderRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByUserID provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) GetByUserID(ctx context.Context, userID uuid.UUID, limit int, offset int) ([]domain.OrderListItem, int, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, userID, limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []domain.OrderListItem
        var r1 int
        var r2 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) ([]domain.OrderListItem, int, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, userID, limit, offset)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) []domain.OrderListItem); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, userID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.OrderListItem)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, int) int); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, userID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(int)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = returnFunc(ctx, userID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>
        <span class="cov0" title="0">return r0, r1, r2</span>
}

// MockOrderRepository_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockOrderRepository_GetByUserID_Call struct {
        *mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - ctx
//   - userID
//   - limit
//   - offset
func (_e *MockOrderRepository_Expecter) GetByUserID(ctx interface{}, userID interface{}, limit interface{}, offset interface{}) *MockOrderRepository_GetByUserID_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepository_GetByUserID_Call{Call: _e.mock.On("GetByUserID", ctx, userID, limit, offset)}
}</span>

func (_c *MockOrderRepository_GetByUserID_Call) Run(run func(ctx context.Context, userID uuid.UUID, limit int, offset int)) *MockOrderRepository_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepository_GetByUserID_Call) Return(orderListItems []domain.OrderListItem, n int, err error) *MockOrderRepository_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(orderListItems, n, err)
        return _c
}</span>

func (_c *MockOrderRepository_GetByUserID_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, limit int, offset int) ([]domain.OrderListItem, int, error)) *MockOrderRepository_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Updatestatus provides a mock function for the type MockOrderRepository
func (_mock *MockOrderRepository) Updatestatus(ctx context.Context, orderID uuid.UUID, status domain.OrderStatus) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, orderID, status)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Updatestatus")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, domain.OrderStatus) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, orderID, status)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepository_Updatestatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Updatestatus'
type MockOrderRepository_Updatestatus_Call struct {
        *mock.Call
}

// Updatestatus is a helper method to define mock.On call
//   - ctx
//   - orderID
//   - status
func (_e *MockOrderRepository_Expecter) Updatestatus(ctx interface{}, orderID interface{}, status interface{}) *MockOrderRepository_Updatestatus_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepository_Updatestatus_Call{Call: _e.mock.On("Updatestatus", ctx, orderID, status)}
}</span>

func (_c *MockOrderRepository_Updatestatus_Call) Run(run func(ctx context.Context, orderID uuid.UUID, status domain.OrderStatus)) *MockOrderRepository_Updatestatus_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(domain.OrderStatus))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepository_Updatestatus_Call) Return(err error) *MockOrderRepository_Updatestatus_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockOrderRepository_Updatestatus_Call) RunAndReturn(run func(ctx context.Context, orderID uuid.UUID, status domain.OrderStatus) error) *MockOrderRepository_Updatestatus_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockProductRepository creates a new instance of MockProductRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProductRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockProductRepository <span class="cov0" title="0">{
        mock := &amp;MockProductRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockProductRepository is an autogenerated mock type for the ProductRepository type
type MockProductRepository struct {
        mock.Mock
}

type MockProductRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockProductRepository) EXPECT() *MockProductRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockProductRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) Create(ctx context.Context, product *domain.Product) (uuid.UUID, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, product)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 uuid.UUID
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Product) (uuid.UUID, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, product)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Product) uuid.UUID); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, product)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(uuid.UUID)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.Product) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, product)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProductRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - product
func (_e *MockProductRepository_Expecter) Create(ctx interface{}, product interface{}) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_Create_Call{Call: _e.mock.On("Create", ctx, product)}
}</span>

func (_c *MockProductRepository_Create_Call) Run(run func(ctx context.Context, product *domain.Product)) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.Product))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_Create_Call) Return(uUID uuid.UUID, err error) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(uUID, err)
        return _c
}</span>

func (_c *MockProductRepository_Create_Call) RunAndReturn(run func(ctx context.Context, product *domain.Product) (uuid.UUID, error)) *MockProductRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// RetrieveAll provides a mock function for the type MockProductRepository
func (_mock *MockProductRepository) RetrieveAll(ctx context.Context, limit int, offset int) ([]domain.RetrieveProduct, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for RetrieveAll")</span>
        }

        <span class="cov0" title="0">var r0 []domain.RetrieveProduct
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]domain.RetrieveProduct, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, limit, offset)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []domain.RetrieveProduct); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.RetrieveProduct)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepository_RetrieveAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetrieveAll'
type MockProductRepository_RetrieveAll_Call struct {
        *mock.Call
}

// RetrieveAll is a helper method to define mock.On call
//   - ctx
//   - limit
//   - offset
func (_e *MockProductRepository_Expecter) RetrieveAll(ctx interface{}, limit interface{}, offset interface{}) *MockProductRepository_RetrieveAll_Call <span class="cov0" title="0">{
        return &amp;MockProductRepository_RetrieveAll_Call{Call: _e.mock.On("RetrieveAll", ctx, limit, offset)}
}</span>

func (_c *MockProductRepository_RetrieveAll_Call) Run(run func(ctx context.Context, limit int, offset int)) *MockProductRepository_RetrieveAll_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(int), args[2].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepository_RetrieveAll_Call) Return(retrieveProducts []domain.RetrieveProduct, err error) *MockProductRepository_RetrieveAll_Call <span class="cov0" title="0">{
        _c.Call.Return(retrieveProducts, err)
        return _c
}</span>

func (_c *MockProductRepository_RetrieveAll_Call) RunAndReturn(run func(ctx context.Context, limit int, offset int) ([]domain.RetrieveProduct, error)) *MockProductRepository_RetrieveAll_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockProductStockRepository creates a new instance of MockProductStockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProductStockRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockProductStockRepository <span class="cov0" title="0">{
        mock := &amp;MockProductStockRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockProductStockRepository is an autogenerated mock type for the ProductStockRepository type
type MockProductStockRepository struct {
        mock.Mock
}

type MockProductStockRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockProductStockRepository) EXPECT() *MockProductStockRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// AddStock provides a mock function for the type MockProductStockRepository
func (_mock *MockProductStockRepository) AddStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, warehouseID, quantity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddStock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductStockRepository_AddStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddStock'
type MockProductStockRepository_AddStock_Call struct {
        *mock.Call
}

// AddStock is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - warehouseID
//   - quantity
func (_e *MockProductStockRepository_Expecter) AddStock(ctx interface{}, tx interface{}, productID interface{}, warehouseID interface{}, quantity interface{}) *MockProductStockRepository_AddStock_Call <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_AddStock_Call{Call: _e.mock.On("AddStock", ctx, tx, productID, warehouseID, quantity)}
}</span>

func (_c *MockProductStockRepository_AddStock_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32)) *MockProductStockRepository_AddStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(int32))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductStockRepository_AddStock_Call) Return(err error) *MockProductStockRepository_AddStock_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductStockRepository_AddStock_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error) *MockProductStockRepository_AddStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CommitStock provides a mock function for the type MockProductStockRepository
func (_mock *MockProductStockRepository) CommitStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, warehouseID, quantity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CommitStock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductStockRepository_CommitStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitStock'
type MockProductStockRepository_CommitStock_Call struct {
        *mock.Call
}

// CommitStock is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - warehouseID
//   - quantity
func (_e *MockProductStockRepository_Expecter) CommitStock(ctx interface{}, tx interface{}, productID interface{}, warehouseID interface{}, quantity interface{}) *MockProductStockRepository_CommitStock_Call <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_CommitStock_Call{Call: _e.mock.On("CommitStock", ctx, tx, productID, warehouseID, quantity)}
}</span>

func (_c *MockProductStockRepository_CommitStock_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32)) *MockProductStockRepository_CommitStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(int32))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductStockRepository_CommitStock_Call) Return(err error) *MockProductStockRepository_CommitStock_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductStockRepository_CommitStock_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error) *MockProductStockRepository_CommitStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Create provides a mock function for the type MockProductStockRepository
func (_mock *MockProductStockRepository) Create(ctx context.Context, productStock *domain.ProductStock) (uuid.UUID, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, productStock)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 uuid.UUID
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.ProductStock) (uuid.UUID, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, productStock)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.ProductStock) uuid.UUID); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, productStock)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(uuid.UUID)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.ProductStock) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, productStock)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductStockRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProductStockRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - productStock
func (_e *MockProductStockRepository_Expecter) Create(ctx interface{}, productStock interface{}) *MockProductStockRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_Create_Call{Call: _e.mock.On("Create", ctx, productStock)}
}</span>

func (_c *MockProductStockRepository_Create_Call) Run(run func(ctx context.Context, productStock *domain.ProductStock)) *MockProductStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.ProductStock))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductStockRepository_Create_Call) Return(uUID uuid.UUID, err error) *MockProductStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(uUID, err)
        return _c
}</span>

func (_c *MockProductStockRepository_Create_Call) RunAndReturn(run func(ctx context.Context, productStock *domain.ProductStock) (uuid.UUID, error)) *MockProductStockRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// ReleaseStock provides a mock function for the type MockProductStockRepository
func (_mock *MockProductStockRepository) ReleaseStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, warehouseID, quantity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ReleaseStock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockProductStockRepository_ReleaseStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseStock'
type MockProductStockRepository_ReleaseStock_Call struct {
        *mock.Call
}

// ReleaseStock is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - warehouseID
//   - quantity
func (_e *MockProductStockRepository_Expecter) ReleaseStock(ctx interface{}, tx interface{}, productID interface{}, warehouseID interface{}, quantity interface{}) *MockProductStockRepository_ReleaseStock_Call <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_ReleaseStock_Call{Call: _e.mock.On("ReleaseStock", ctx, tx, productID, warehouseID, quantity)}
}</span>

func (_c *MockProductStockRepository_ReleaseStock_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32)) *MockProductStockRepository_ReleaseStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(int32))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductStockRepository_ReleaseStock_Call) Return(err error) *MockProductStockRepository_ReleaseStock_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockProductStockRepository_ReleaseStock_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error) *MockProductStockRepository_ReleaseStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// TryReserveStock provides a mock function for the type MockProductStockRepository
func (_mock *MockProductStockRepository) TryReserveStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) (bool, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, warehouseID, quantity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for TryReserveStock")</span>
        }

        <span class="cov0" title="0">var r0 bool
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) (bool, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) bool); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(bool)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, uuid.UUID, uuid.UUID, int32) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, productID, warehouseID, quantity)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductStockRepository_TryReserveStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TryReserveStock'
type MockProductStockRepository_TryReserveStock_Call struct {
        *mock.Call
}

// TryReserveStock is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - warehouseID
//   - quantity
func (_e *MockProductStockRepository_Expecter) TryReserveStock(ctx interface{}, tx interface{}, productID interface{}, warehouseID interface{}, quantity interface{}) *MockProductStockRepository_TryReserveStock_Call <span class="cov0" title="0">{
        return &amp;MockProductStockRepository_TryReserveStock_Call{Call: _e.mock.On("TryReserveStock", ctx, tx, productID, warehouseID, quantity)}
}</span>

func (_c *MockProductStockRepository_TryReserveStock_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32)) *MockProductStockRepository_TryReserveStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(uuid.UUID), args[4].(int32))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductStockRepository_TryReserveStock_Call) Return(b bool, err error) *MockProductStockRepository_TryReserveStock_Call <span class="cov0" title="0">{
        _c.Call.Return(b, err)
        return _c
}</span>

func (_c *MockProductStockRepository_TryReserveStock_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) (bool, error)) *MockProductStockRepository_TryReserveStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockReservationRepository creates a new instance of MockReservationRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReservationRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockReservationRepository <span class="cov0" title="0">{
        mock := &amp;MockReservationRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockReservationRepository is an autogenerated mock type for the ReservationRepository type
type MockReservationRepository struct {
        mock.Mock
}

type MockReservationRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockReservationRepository) EXPECT() *MockReservationRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockReservationRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateMany provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) CreateMany(ctx context.Context, tx *sql.Tx, reservations []domain.Reservation) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, reservations)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateMany")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, []domain.Reservation) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, reservations)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockReservationRepository_CreateMany_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMany'
type MockReservationRepository_CreateMany_Call struct {
        *mock.Call
}

// CreateMany is a helper method to define mock.On call
//   - ctx
//   - tx
//   - reservations
func (_e *MockReservationRepository_Expecter) CreateMany(ctx interface{}, tx interface{}, reservations interface{}) *MockReservationRepository_CreateMany_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_CreateMany_Call{Call: _e.mock.On("CreateMany", ctx, tx, reservations)}
}</span>

func (_c *MockReservationRepository_CreateMany_Call) Run(run func(ctx context.Context, tx *sql.Tx, reservations []domain.Reservation)) *MockReservationRepository_CreateMany_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].([]domain.Reservation))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_CreateMany_Call) Return(err error) *MockReservationRepository_CreateMany_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockReservationRepository_CreateMany_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, reservations []domain.Reservation) error) *MockReservationRepository_CreateMany_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByOrderID provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) GetByOrderID(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) ([]domain.Reservation, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, orderID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByOrderID")</span>
        }

        <span class="cov0" title="0">var r0 []domain.Reservation
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) ([]domain.Reservation, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, orderID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) []domain.Reservation); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.Reservation)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockReservationRepository_GetByOrderID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByOrderID'
type MockReservationRepository_GetByOrderID_Call struct {
        *mock.Call
}

// GetByOrderID is a helper method to define mock.On call
//   - ctx
//   - tx
//   - orderID
func (_e *MockReservationRepository_Expecter) GetByOrderID(ctx interface{}, tx interface{}, orderID interface{}) *MockReservationRepository_GetByOrderID_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_GetByOrderID_Call{Call: _e.mock.On("GetByOrderID", ctx, tx, orderID)}
}</span>

func (_c *MockReservationRepository_GetByOrderID_Call) Run(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID)) *MockReservationRepository_GetByOrderID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_GetByOrderID_Call) Return(reservations []domain.Reservation, err error) *MockReservationRepository_GetByOrderID_Call <span class="cov0" title="0">{
        _c.Call.Return(reservations, err)
        return _c
}</span>

func (_c *MockReservationRepository_GetByOrderID_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) ([]domain.Reservation, error)) *MockReservationRepository_GetByOrderID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MarkCommitted provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) MarkCommitted(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, orderID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MarkCommitted")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockReservationRepository_MarkCommitted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkCommitted'
type MockReservationRepository_MarkCommitted_Call struct {
        *mock.Call
}

// MarkCommitted is a helper method to define mock.On call
//   - ctx
//   - tx
//   - orderID
func (_e *MockReservationRepository_Expecter) MarkCommitted(ctx interface{}, tx interface{}, orderID interface{}) *MockReservationRepository_MarkCommitted_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_MarkCommitted_Call{Call: _e.mock.On("MarkCommitted", ctx, tx, orderID)}
}</span>

func (_c *MockReservationRepository_MarkCommitted_Call) Run(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID)) *MockReservationRepository_MarkCommitted_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_MarkCommitted_Call) Return(err error) *MockReservationRepository_MarkCommitted_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockReservationRepository_MarkCommitted_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error) *MockReservationRepository_MarkCommitted_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MarkExpired provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) MarkExpired(ctx context.Context, tx *sql.Tx, id uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MarkExpired")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockReservationRepository_MarkExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkExpired'
type MockReservationRepository_MarkExpired_Call struct {
        *mock.Call
}

// MarkExpired is a helper method to define mock.On call
//   - ctx
//   - tx
//   - id
func (_e *MockReservationRepository_Expecter) MarkExpired(ctx interface{}, tx interface{}, id interface{}) *MockReservationRepository_MarkExpired_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_MarkExpired_Call{Call: _e.mock.On("MarkExpired", ctx, tx, id)}
}</span>

func (_c *MockReservationRepository_MarkExpired_Call) Run(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID)) *MockReservationRepository_MarkExpired_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_MarkExpired_Call) Return(err error) *MockReservationRepository_MarkExpired_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockReservationRepository_MarkExpired_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID) error) *MockReservationRepository_MarkExpired_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// MarkReleased provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) MarkReleased(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, orderID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MarkReleased")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockReservationRepository_MarkReleased_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkReleased'
type MockReservationRepository_MarkReleased_Call struct {
        *mock.Call
}

// MarkReleased is a helper method to define mock.On call
//   - ctx
//   - tx
//   - orderID
func (_e *MockReservationRepository_Expecter) MarkReleased(ctx interface{}, tx interface{}, orderID interface{}) *MockReservationRepository_MarkReleased_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_MarkReleased_Call{Call: _e.mock.On("MarkReleased", ctx, tx, orderID)}
}</span>

func (_c *MockReservationRepository_MarkReleased_Call) Run(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID)) *MockReservationRepository_MarkReleased_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_MarkReleased_Call) Return(err error) *MockReservationRepository_MarkReleased_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockReservationRepository_MarkReleased_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error) *MockReservationRepository_MarkReleased_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// PendingCountByOrder provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) PendingCountByOrder(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) (int, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, orderID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PendingCountByOrder")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) (int, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, orderID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) int); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, orderID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockReservationRepository_PendingCountByOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PendingCountByOrder'
type MockReservationRepository_PendingCountByOrder_Call struct {
        *mock.Call
}

// PendingCountByOrder is a helper method to define mock.On call
//   - ctx
//   - tx
//   - orderID
func (_e *MockReservationRepository_Expecter) PendingCountByOrder(ctx interface{}, tx interface{}, orderID interface{}) *MockReservationRepository_PendingCountByOrder_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_PendingCountByOrder_Call{Call: _e.mock.On("PendingCountByOrder", ctx, tx, orderID)}
}</span>

func (_c *MockReservationRepository_PendingCountByOrder_Call) Run(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID)) *MockReservationRepository_PendingCountByOrder_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_PendingCountByOrder_Call) Return(n int, err error) *MockReservationRepository_PendingCountByOrder_Call <span class="cov0" title="0">{
        _c.Call.Return(n, err)
        return _c
}</span>

func (_c *MockReservationRepository_PendingCountByOrder_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) (int, error)) *MockReservationRepository_PendingCountByOrder_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// PickExpiredForUpdate provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) PickExpiredForUpdate(ctx context.Context, tx *sql.Tx, limit int) ([]domain.Reservation, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, limit)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for PickExpiredForUpdate")</span>
        }

        <span class="cov0" title="0">var r0 []domain.Reservation
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, int) ([]domain.Reservation, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, limit)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, int) []domain.Reservation); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, limit)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.Reservation)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, int) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, limit)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockReservationRepository_PickExpiredForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PickExpiredForUpdate'
type MockReservationRepository_PickExpiredForUpdate_Call struct {
        *mock.Call
}

// PickExpiredForUpdate is a helper method to define mock.On call
//   - ctx
//   - tx
//   - limit
func (_e *MockReservationRepository_Expecter) PickExpiredForUpdate(ctx interface{}, tx interface{}, limit interface{}) *MockReservationRepository_PickExpiredForUpdate_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_PickExpiredForUpdate_Call{Call: _e.mock.On("PickExpiredForUpdate", ctx, tx, limit)}
}</span>

func (_c *MockReservationRepository_PickExpiredForUpdate_Call) Run(run func(ctx context.Context, tx *sql.Tx, limit int)) *MockReservationRepository_PickExpiredForUpdate_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_PickExpiredForUpdate_Call) Return(reservations []domain.Reservation, err error) *MockReservationRepository_PickExpiredForUpdate_Call <span class="cov0" title="0">{
        _c.Call.Return(reservations, err)
        return _c
}</span>

func (_c *MockReservationRepository_PickExpiredForUpdate_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, limit int) ([]domain.Reservation, error)) *MockReservationRepository_PickExpiredForUpdate_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Retrieve provides a mock function for the type MockReservationRepository
func (_mock *MockReservationRepository) Retrieve(ctx context.Context, tx *sql.Tx, id uuid.UUID) (*domain.Reservation, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Retrieve")</span>
        }

        <span class="cov0" title="0">var r0 *domain.Reservation
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) (*domain.Reservation, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, id)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID) *domain.Reservation); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.Reservation)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockReservationRepository_Retrieve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retrieve'
type MockReservationRepository_Retrieve_Call struct {
        *mock.Call
}

// Retrieve is a helper method to define mock.On call
//   - ctx
//   - tx
//   - id
func (_e *MockReservationRepository_Expecter) Retrieve(ctx interface{}, tx interface{}, id interface{}) *MockReservationRepository_Retrieve_Call <span class="cov0" title="0">{
        return &amp;MockReservationRepository_Retrieve_Call{Call: _e.mock.On("Retrieve", ctx, tx, id)}
}</span>

func (_c *MockReservationRepository_Retrieve_Call) Run(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID)) *MockReservationRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockReservationRepository_Retrieve_Call) Return(reservation *domain.Reservation, err error) *MockReservationRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(reservation, err)
        return _c
}</span>

func (_c *MockReservationRepository_Retrieve_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID) (*domain.Reservation, error)) *MockReservationRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockShopRepository creates a new instance of MockShopRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockShopRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockShopRepository <span class="cov0" title="0">{
        mock := &amp;MockShopRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockShopRepository is an autogenerated mock type for the ShopRepository type
type MockShopRepository struct {
        mock.Mock
}

type MockShopRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockShopRepository) EXPECT() *MockShopRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockShopRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function for the type MockShopRepository
func (_mock *MockShopRepository) Create(ctx context.Context, shop *domain.Shop) (uuid.UUID, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, shop)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 uuid.UUID
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Shop) (uuid.UUID, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, shop)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Shop) uuid.UUID); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, shop)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(uuid.UUID)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.Shop) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, shop)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockShopRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockShopRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - shop
func (_e *MockShopRepository_Expecter) Create(ctx interface{}, shop interface{}) *MockShopRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockShopRepository_Create_Call{Call: _e.mock.On("Create", ctx, shop)}
}</span>

func (_c *MockShopRepository_Create_Call) Run(run func(ctx context.Context, shop *domain.Shop)) *MockShopRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.Shop))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockShopRepository_Create_Call) Return(uUID uuid.UUID, err error) *MockShopRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(uUID, err)
        return _c
}</span>

func (_c *MockShopRepository_Create_Call) RunAndReturn(run func(ctx context.Context, shop *domain.Shop) (uuid.UUID, error)) *MockShopRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function for the type MockShopRepository
func (_mock *MockShopRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockShopRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockShopRepository_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockShopRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockShopRepository_Delete_Call <span class="cov0" title="0">{
        return &amp;MockShopRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}</span>

func (_c *MockShopRepository_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockShopRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockShopRepository_Delete_Call) Return(err error) *MockShopRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockShopRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockShopRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Retrieve provides a mock function for the type MockShopRepository
func (_mock *MockShopRepository) Retrieve(ctx context.Context, id uuid.UUID) (*domain.Shop, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Retrieve")</span>
        }

        <span class="cov0" title="0">var r0 *domain.Shop
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Shop, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, id)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Shop); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.Shop)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockShopRepository_Retrieve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retrieve'
type MockShopRepository_Retrieve_Call struct {
        *mock.Call
}

// Retrieve is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockShopRepository_Expecter) Retrieve(ctx interface{}, id interface{}) *MockShopRepository_Retrieve_Call <span class="cov0" title="0">{
        return &amp;MockShopRepository_Retrieve_Call{Call: _e.mock.On("Retrieve", ctx, id)}
}</span>

func (_c *MockShopRepository_Retrieve_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockShopRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockShopRepository_Retrieve_Call) Return(shop *domain.Shop, err error) *MockShopRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(shop, err)
        return _c
}</span>

func (_c *MockShopRepository_Retrieve_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.Shop, error)) *MockShopRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function for the type MockShopRepository
func (_mock *MockShopRepository) Update(ctx context.Context, shop *domain.Shop) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, shop)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Shop) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, shop)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockShopRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockShopRepository_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - shop
func (_e *MockShopRepository_Expecter) Update(ctx interface{}, shop interface{}) *MockShopRepository_Update_Call <span class="cov0" title="0">{
        return &amp;MockShopRepository_Update_Call{Call: _e.mock.On("Update", ctx, shop)}
}</span>

func (_c *MockShopRepository_Update_Call) Run(run func(ctx context.Context, shop *domain.Shop)) *MockShopRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.Shop))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockShopRepository_Update_Call) Return(err error) *MockShopRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockShopRepository_Update_Call) RunAndReturn(run func(ctx context.Context, shop *domain.Shop) error) *MockShopRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"

        "github.com/dyaksa/warehouse/domain"
        mock "github.com/stretchr/testify/mock"
)

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
        mock.Mock
}

type MockUserRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockUserRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateUser provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) CreateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockUserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserRepository_CreateUser_Call struct {
        *mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx
//   - user
func (_e *MockUserRepository_Expecter) CreateUser(ctx interface{}, user interface{}) *MockUserRepository_CreateUser_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}</span>

func (_c *MockUserRepository_CreateUser_Call) Run(run func(ctx context.Context, user *domain.User)) *MockUserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_CreateUser_Call) Return(err error) *MockUserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockUserRepository_CreateUser_Call) RunAndReturn(run func(ctx context.Context, user *domain.User) error) *MockUserRepository_CreateUser_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetMailOrPhone provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetMailOrPhone(ctx context.Context, email_bidx string, phone_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, email_bidx, phone_bidx, fn)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetMailOrPhone")</span>
        }

        <span class="cov0" title="0">var r0 *domain.User
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, func(data *domain.User)) (*domain.User, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, email_bidx, phone_bidx, fn)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, func(data *domain.User)) *domain.User); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, email_bidx, phone_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.User)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string, string, func(data *domain.User)) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, email_bidx, phone_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_GetMailOrPhone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMailOrPhone'
type MockUserRepository_GetMailOrPhone_Call struct {
        *mock.Call
}

// GetMailOrPhone is a helper method to define mock.On call
//   - ctx
//   - email_bidx
//   - phone_bidx
//   - fn
func (_e *MockUserRepository_Expecter) GetMailOrPhone(ctx interface{}, email_bidx interface{}, phone_bidx interface{}, fn interface{}) *MockUserRepository_GetMailOrPhone_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_GetMailOrPhone_Call{Call: _e.mock.On("GetMailOrPhone", ctx, email_bidx, phone_bidx, fn)}
}</span>

func (_c *MockUserRepository_GetMailOrPhone_Call) Run(run func(ctx context.Context, email_bidx string, phone_bidx string, fn func(data *domain.User))) *MockUserRepository_GetMailOrPhone_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(func(data *domain.User)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_GetMailOrPhone_Call) Return(user *domain.User, err error) *MockUserRepository_GetMailOrPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(user, err)
        return _c
}</span>

func (_c *MockUserRepository_GetMailOrPhone_Call) RunAndReturn(run func(ctx context.Context, email_bidx string, phone_bidx string, fn func(data *domain.User)) (*domain.User, error)) *MockUserRepository_GetMailOrPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserByEmail(ctx context.Context, email_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, email_bidx, fn)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByEmail")</span>
        }

        <span class="cov0" title="0">var r0 *domain.User
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, func(data *domain.User)) (*domain.User, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, email_bidx, fn)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string, func(data *domain.User)) *domain.User); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, email_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.User)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string, func(data *domain.User)) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, email_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockUserRepository_GetUserByEmail_Call struct {
        *mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx
//   - email_bidx
//   - fn
func (_e *MockUserRepository_Expecter) GetUserByEmail(ctx interface{}, email_bidx interface{}, fn interface{}) *MockUserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email_bidx, fn)}
}</span>

func (_c *MockUserRepository_GetUserByEmail_Call) Run(run func(ctx context.Context, email_bidx string, fn func(data *domain.User))) *MockUserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(func(data *domain.User)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_GetUserByEmail_Call) Return(user *domain.User, err error) *MockUserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(user, err)
        return _c
}</span>

func (_c *MockUserRepository_GetUserByEmail_Call) RunAndReturn(run func(ctx context.Context, email_bidx string, fn func(data *domain.User)) (*domain.User, error)) *MockUserRepository_GetUserByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetUserByPhone provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserByPhone(ctx context.Context, phone_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, phone_bidx, fn)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetUserByPhone")</span>
        }

        <span class="cov0" title="0">var r0 *domain.User
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, string, func(data *domain.User)) (*domain.User, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, phone_bidx, fn)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, string, func(data *domain.User)) *domain.User); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, phone_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.User)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, string, func(data *domain.User)) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, phone_bidx, fn)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepository_GetUserByPhone_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByPhone'
type MockUserRepository_GetUserByPhone_Call struct {
        *mock.Call
}

// GetUserByPhone is a helper method to define mock.On call
//   - ctx
//   - phone_bidx
//   - fn
func (_e *MockUserRepository_Expecter) GetUserByPhone(ctx interface{}, phone_bidx interface{}, fn interface{}) *MockUserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        return &amp;MockUserRepository_GetUserByPhone_Call{Call: _e.mock.On("GetUserByPhone", ctx, phone_bidx, fn)}
}</span>

func (_c *MockUserRepository_GetUserByPhone_Call) Run(run func(ctx context.Context, phone_bidx string, fn func(data *domain.User))) *MockUserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(string), args[2].(func(data *domain.User)))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepository_GetUserByPhone_Call) Return(user *domain.User, err error) *MockUserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(user, err)
        return _c
}</span>

func (_c *MockUserRepository_GetUserByPhone_Call) RunAndReturn(run func(ctx context.Context, phone_bidx string, fn func(data *domain.User)) (*domain.User, error)) *MockUserRepository_GetUserByPhone_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockWarehouseRepository creates a new instance of MockWarehouseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWarehouseRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockWarehouseRepository <span class="cov0" title="0">{
        mock := &amp;MockWarehouseRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockWarehouseRepository is an autogenerated mock type for the WarehouseRepository type
type MockWarehouseRepository struct {
        mock.Mock
}

type MockWarehouseRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockWarehouseRepository) EXPECT() *MockWarehouseRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) Create(ctx context.Context, w *domain.WareHouse) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, w)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.WareHouse) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, w)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockWarehouseRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - w
func (_e *MockWarehouseRepository_Expecter) Create(ctx interface{}, w interface{}) *MockWarehouseRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Create_Call{Call: _e.mock.On("Create", ctx, w)}
}</span>

func (_c *MockWarehouseRepository_Create_Call) Run(run func(ctx context.Context, w *domain.WareHouse)) *MockWarehouseRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.WareHouse))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_Create_Call) Return(err error) *MockWarehouseRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseRepository_Create_Call) RunAndReturn(run func(ctx context.Context, w *domain.WareHouse) error) *MockWarehouseRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockWarehouseRepository_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockWarehouseRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockWarehouseRepository_Delete_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}</span>

func (_c *MockWarehouseRepository_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockWarehouseRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_Delete_Call) Return(err error) *MockWarehouseRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockWarehouseRepository_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByShopID provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) GetByShopID(ctx context.Context, shopID uuid.UUID) ([]domain.WareHouse, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, shopID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByShopID")</span>
        }

        <span class="cov0" title="0">var r0 []domain.WareHouse
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]domain.WareHouse, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, shopID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []domain.WareHouse); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, shopID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.WareHouse)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, shopID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseRepository_GetByShopID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByShopID'
type MockWarehouseRepository_GetByShopID_Call struct {
        *mock.Call
}

// GetByShopID is a helper method to define mock.On call
//   - ctx
//   - shopID
func (_e *MockWarehouseRepository_Expecter) GetByShopID(ctx interface{}, shopID interface{}) *MockWarehouseRepository_GetByShopID_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_GetByShopID_Call{Call: _e.mock.On("GetByShopID", ctx, shopID)}
}</span>

func (_c *MockWarehouseRepository_GetByShopID_Call) Run(run func(ctx context.Context, shopID uuid.UUID)) *MockWarehouseRepository_GetByShopID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_GetByShopID_Call) Return(wareHouses []domain.WareHouse, err error) *MockWarehouseRepository_GetByShopID_Call <span class="cov0" title="0">{
        _c.Call.Return(wareHouses, err)
        return _c
}</span>

func (_c *MockWarehouseRepository_GetByShopID_Call) RunAndReturn(run func(ctx context.Context, shopID uuid.UUID) ([]domain.WareHouse, error)) *MockWarehouseRepository_GetByShopID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Pick provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) Pick(ctx context.Context, tx *sql.Tx, productID uuid.UUID, qty int, shopID uuid.UUID) (uuid.UUID, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, productID, qty, shopID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Pick")</span>
        }

        <span class="cov0" title="0">var r0 uuid.UUID
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, int, uuid.UUID) (uuid.UUID, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, tx, productID, qty, shopID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, int, uuid.UUID) uuid.UUID); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, productID, qty, shopID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(uuid.UUID)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, *sql.Tx, uuid.UUID, int, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, tx, productID, qty, shopID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseRepository_Pick_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pick'
type MockWarehouseRepository_Pick_Call struct {
        *mock.Call
}

// Pick is a helper method to define mock.On call
//   - ctx
//   - tx
//   - productID
//   - qty
//   - shopID
func (_e *MockWarehouseRepository_Expecter) Pick(ctx interface{}, tx interface{}, productID interface{}, qty interface{}, shopID interface{}) *MockWarehouseRepository_Pick_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Pick_Call{Call: _e.mock.On("Pick", ctx, tx, productID, qty, shopID)}
}</span>

func (_c *MockWarehouseRepository_Pick_Call) Run(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, qty int, shopID uuid.UUID)) *MockWarehouseRepository_Pick_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(int), args[4].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_Pick_Call) Return(warehouseID uuid.UUID, err error) *MockWarehouseRepository_Pick_Call <span class="cov0" title="0">{
        _c.Call.Return(warehouseID, err)
        return _c
}</span>

func (_c *MockWarehouseRepository_Pick_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, productID uuid.UUID, qty int, shopID uuid.UUID) (uuid.UUID, error)) *MockWarehouseRepository_Pick_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Retrieve provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) Retrieve(ctx context.Context, id uuid.UUID) (*domain.WareHouse, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Retrieve")</span>
        }

        <span class="cov0" title="0">var r0 *domain.WareHouse
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.WareHouse, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, id)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.WareHouse); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.WareHouse)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseRepository_Retrieve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Retrieve'
type MockWarehouseRepository_Retrieve_Call struct {
        *mock.Call
}

// Retrieve is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockWarehouseRepository_Expecter) Retrieve(ctx interface{}, id interface{}) *MockWarehouseRepository_Retrieve_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Retrieve_Call{Call: _e.mock.On("Retrieve", ctx, id)}
}</span>

func (_c *MockWarehouseRepository_Retrieve_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockWarehouseRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_Retrieve_Call) Return(wareHouse *domain.WareHouse, err error) *MockWarehouseRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(wareHouse, err)
        return _c
}</span>

func (_c *MockWarehouseRepository_Retrieve_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.WareHouse, error)) *MockWarehouseRepository_Retrieve_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SetActive provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) SetActive(ctx context.Context, id uuid.UUID, isActive bool) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id, isActive)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetActive")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, bool) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id, isActive)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseRepository_SetActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetActive'
type MockWarehouseRepository_SetActive_Call struct {
        *mock.Call
}

// SetActive is a helper method to define mock.On call
//   - ctx
//   - id
//   - isActive
func (_e *MockWarehouseRepository_Expecter) SetActive(ctx interface{}, id interface{}, isActive interface{}) *MockWarehouseRepository_SetActive_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_SetActive_Call{Call: _e.mock.On("SetActive", ctx, id, isActive)}
}</span>

func (_c *MockWarehouseRepository_SetActive_Call) Run(run func(ctx context.Context, id uuid.UUID, isActive bool)) *MockWarehouseRepository_SetActive_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(bool))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_SetActive_Call) Return(err error) *MockWarehouseRepository_SetActive_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseRepository_SetActive_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, isActive bool) error) *MockWarehouseRepository_SetActive_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function for the type MockWarehouseRepository
func (_mock *MockWarehouseRepository) Update(ctx context.Context, w *domain.WareHouse) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, w)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.WareHouse) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, w)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockWarehouseRepository_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - w
func (_e *MockWarehouseRepository_Expecter) Update(ctx interface{}, w interface{}) *MockWarehouseRepository_Update_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseRepository_Update_Call{Call: _e.mock.On("Update", ctx, w)}
}</span>

func (_c *MockWarehouseRepository_Update_Call) Run(run func(ctx context.Context, w *domain.WareHouse)) *MockWarehouseRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*domain.WareHouse))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseRepository_Update_Call) Return(err error) *MockWarehouseRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseRepository_Update_Call) RunAndReturn(run func(ctx context.Context, w *domain.WareHouse) error) *MockWarehouseRepository_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
        "context"
        "database/sql"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
        mock "github.com/stretchr/testify/mock"
)

// NewMockWarehouseTransferRepository creates a new instance of MockWarehouseTransferRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWarehouseTransferRepository(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockWarehouseTransferRepository <span class="cov0" title="0">{
        mock := &amp;MockWarehouseTransferRepository{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}

// MockWarehouseTransferRepository is an autogenerated mock type for the WarehouseTransferRepository type
type MockWarehouseTransferRepository struct {
        mock.Mock
}

type MockWarehouseTransferRepository_Expecter struct {
        mock *mock.Mock
}

func (_m *MockWarehouseTransferRepository) EXPECT() *MockWarehouseTransferRepository_Expecter <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) Create(ctx context.Context, tx *sql.Tx, transfer *domain.WarehouseTransfer) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, transfer)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, *domain.WarehouseTransfer) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, transfer)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseTransferRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockWarehouseTransferRepository_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - tx
//   - transfer
func (_e *MockWarehouseTransferRepository_Expecter) Create(ctx interface{}, tx interface{}, transfer interface{}) *MockWarehouseTransferRepository_Create_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_Create_Call{Call: _e.mock.On("Create", ctx, tx, transfer)}
}</span>

func (_c *MockWarehouseTransferRepository_Create_Call) Run(run func(ctx context.Context, tx *sql.Tx, transfer *domain.WarehouseTransfer)) *MockWarehouseTransferRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(*domain.WarehouseTransfer))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_Create_Call) Return(err error) *MockWarehouseTransferRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_Create_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, transfer *domain.WarehouseTransfer) error) *MockWarehouseTransferRepository_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateItems provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) CreateItems(ctx context.Context, tx *sql.Tx, items []domain.WarehouseTransferItem) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, items)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateItems")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, []domain.WarehouseTransferItem) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, items)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseTransferRepository_CreateItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateItems'
type MockWarehouseTransferRepository_CreateItems_Call struct {
        *mock.Call
}

// CreateItems is a helper method to define mock.On call
//   - ctx
//   - tx
//   - items
func (_e *MockWarehouseTransferRepository_Expecter) CreateItems(ctx interface{}, tx interface{}, items interface{}) *MockWarehouseTransferRepository_CreateItems_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_CreateItems_Call{Call: _e.mock.On("CreateItems", ctx, tx, items)}
}</span>

func (_c *MockWarehouseTransferRepository_CreateItems_Call) Run(run func(ctx context.Context, tx *sql.Tx, items []domain.WarehouseTransferItem)) *MockWarehouseTransferRepository_CreateItems_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].([]domain.WarehouseTransferItem))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_CreateItems_Call) Return(err error) *MockWarehouseTransferRepository_CreateItems_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_CreateItems_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, items []domain.WarehouseTransferItem) error) *MockWarehouseTransferRepository_CreateItems_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetActiveTransfersByWarehouse provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) GetActiveTransfersByWarehouse(ctx context.Context, warehouseID uuid.UUID) ([]domain.WarehouseTransfer, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, warehouseID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetActiveTransfersByWarehouse")</span>
        }

        <span class="cov0" title="0">var r0 []domain.WarehouseTransfer
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]domain.WarehouseTransfer, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, warehouseID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []domain.WarehouseTransfer); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, warehouseID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.WarehouseTransfer)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, warehouseID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveTransfersByWarehouse'
type MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call struct {
        *mock.Call
}

// GetActiveTransfersByWarehouse is a helper method to define mock.On call
//   - ctx
//   - warehouseID
func (_e *MockWarehouseTransferRepository_Expecter) GetActiveTransfersByWarehouse(ctx interface{}, warehouseID interface{}) *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call{Call: _e.mock.On("GetActiveTransfersByWarehouse", ctx, warehouseID)}
}</span>

func (_c *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call) Run(run func(ctx context.Context, warehouseID uuid.UUID)) *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call) Return(warehouseTransfers []domain.WarehouseTransfer, err error) *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Return(warehouseTransfers, err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call) RunAndReturn(run func(ctx context.Context, warehouseID uuid.UUID) ([]domain.WarehouseTransfer, error)) *MockWarehouseTransferRepository_GetActiveTransfersByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.WarehouseTransfer, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *domain.WarehouseTransfer
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.WarehouseTransfer, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, id)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.WarehouseTransfer); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*domain.WarehouseTransfer)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseTransferRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockWarehouseTransferRepository_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *MockWarehouseTransferRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockWarehouseTransferRepository_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}</span>

func (_c *MockWarehouseTransferRepository_GetByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockWarehouseTransferRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_GetByID_Call) Return(warehouseTransfer *domain.WarehouseTransfer, err error) *MockWarehouseTransferRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(warehouseTransfer, err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.WarehouseTransfer, error)) *MockWarehouseTransferRepository_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByWarehouse provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) GetByWarehouse(ctx context.Context, warehouseID uuid.UUID, limit int, offset int) ([]domain.WarehouseTransfer, int, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, warehouseID, limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByWarehouse")</span>
        }

        <span class="cov0" title="0">var r0 []domain.WarehouseTransfer
        var r1 int
        var r2 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) ([]domain.WarehouseTransfer, int, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, warehouseID, limit, offset)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) []domain.WarehouseTransfer); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, warehouseID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.WarehouseTransfer)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, int) int); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, warehouseID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(int)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = returnFunc(ctx, warehouseID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>
        <span class="cov0" title="0">return r0, r1, r2</span>
}

// MockWarehouseTransferRepository_GetByWarehouse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByWarehouse'
type MockWarehouseTransferRepository_GetByWarehouse_Call struct {
        *mock.Call
}

// GetByWarehouse is a helper method to define mock.On call
//   - ctx
//   - warehouseID
//   - limit
//   - offset
func (_e *MockWarehouseTransferRepository_Expecter) GetByWarehouse(ctx interface{}, warehouseID interface{}, limit interface{}, offset interface{}) *MockWarehouseTransferRepository_GetByWarehouse_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_GetByWarehouse_Call{Call: _e.mock.On("GetByWarehouse", ctx, warehouseID, limit, offset)}
}</span>

func (_c *MockWarehouseTransferRepository_GetByWarehouse_Call) Run(run func(ctx context.Context, warehouseID uuid.UUID, limit int, offset int)) *MockWarehouseTransferRepository_GetByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_GetByWarehouse_Call) Return(warehouseTransfers []domain.WarehouseTransfer, n int, err error) *MockWarehouseTransferRepository_GetByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Return(warehouseTransfers, n, err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_GetByWarehouse_Call) RunAndReturn(run func(ctx context.Context, warehouseID uuid.UUID, limit int, offset int) ([]domain.WarehouseTransfer, int, error)) *MockWarehouseTransferRepository_GetByWarehouse_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetItemsByTransferID provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) GetItemsByTransferID(ctx context.Context, transferID uuid.UUID) ([]domain.WarehouseTransferItem, error) <span class="cov0" title="0">{
        ret := _mock.Called(ctx, transferID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetItemsByTransferID")</span>
        }

        <span class="cov0" title="0">var r0 []domain.WarehouseTransferItem
        var r1 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]domain.WarehouseTransferItem, error)); ok </span><span class="cov0" title="0">{
                return returnFunc(ctx, transferID)
        }</span>
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []domain.WarehouseTransferItem); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, transferID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.WarehouseTransferItem)
                }</span>
        }
        <span class="cov0" title="0">if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = returnFunc(ctx, transferID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>
        <span class="cov0" title="0">return r0, r1</span>
}

// MockWarehouseTransferRepository_GetItemsByTransferID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetItemsByTransferID'
type MockWarehouseTransferRepository_GetItemsByTransferID_Call struct {
        *mock.Call
}

// GetItemsByTransferID is a helper method to define mock.On call
//   - ctx
//   - transferID
func (_e *MockWarehouseTransferRepository_Expecter) GetItemsByTransferID(ctx interface{}, transferID interface{}) *MockWarehouseTransferRepository_GetItemsByTransferID_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_GetItemsByTransferID_Call{Call: _e.mock.On("GetItemsByTransferID", ctx, transferID)}
}</span>

func (_c *MockWarehouseTransferRepository_GetItemsByTransferID_Call) Run(run func(ctx context.Context, transferID uuid.UUID)) *MockWarehouseTransferRepository_GetItemsByTransferID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(uuid.UUID))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_GetItemsByTransferID_Call) Return(warehouseTransferItems []domain.WarehouseTransferItem, err error) *MockWarehouseTransferRepository_GetItemsByTransferID_Call <span class="cov0" title="0">{
        _c.Call.Return(warehouseTransferItems, err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_GetItemsByTransferID_Call) RunAndReturn(run func(ctx context.Context, transferID uuid.UUID) ([]domain.WarehouseTransferItem, error)) *MockWarehouseTransferRepository_GetItemsByTransferID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateStatus provides a mock function for the type MockWarehouseTransferRepository
func (_mock *MockWarehouseTransferRepository) UpdateStatus(ctx context.Context, tx *sql.Tx, id uuid.UUID, status domain.TransferStatus) error <span class="cov0" title="0">{
        ret := _mock.Called(ctx, tx, id, status)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateStatus")</span>
        }

        <span class="cov0" title="0">var r0 error
        if returnFunc, ok := ret.Get(0).(func(context.Context, *sql.Tx, uuid.UUID, domain.TransferStatus) error); ok </span><span class="cov0" title="0">{
                r0 = returnFunc(ctx, tx, id, status)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>
        <span class="cov0" title="0">return r0</span>
}

// MockWarehouseTransferRepository_UpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStatus'
type MockWarehouseTransferRepository_UpdateStatus_Call struct {
        *mock.Call
}

// UpdateStatus is a helper method to define mock.On call
//   - ctx
//   - tx
//   - id
//   - status
func (_e *MockWarehouseTransferRepository_Expecter) UpdateStatus(ctx interface{}, tx interface{}, id interface{}, status interface{}) *MockWarehouseTransferRepository_UpdateStatus_Call <span class="cov0" title="0">{
        return &amp;MockWarehouseTransferRepository_UpdateStatus_Call{Call: _e.mock.On("UpdateStatus", ctx, tx, id, status)}
}</span>

func (_c *MockWarehouseTransferRepository_UpdateStatus_Call) Run(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID, status domain.TransferStatus)) *MockWarehouseTransferRepository_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(context.Context), args[1].(*sql.Tx), args[2].(uuid.UUID), args[3].(domain.TransferStatus))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockWarehouseTransferRepository_UpdateStatus_Call) Return(err error) *MockWarehouseTransferRepository_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(err)
        return _c
}</span>

func (_c *MockWarehouseTransferRepository_UpdateStatus_Call) RunAndReturn(run func(ctx context.Context, tx *sql.Tx, id uuid.UUID, status domain.TransferStatus) error) *MockWarehouseTransferRepository_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package hashutils

import "encoding/hex"

func HashPayload(b []byte) string <span class="cov0" title="0">{
        hashed := hex.EncodeToString(b)
        return hashed
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package helper

import (
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/nyaruka/phonenumbers"
)

func NormalizeIdentifier(raw string) (kind string, normalized string, ok bool) <span class="cov0" title="0">{
        s := strings.TrimSpace(raw)

        if validator.New().Var(s, "email") == nil </span><span class="cov0" title="0">{
                parts := strings.Split(s, "@")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        return "email", parts[0] + "@" + strings.ToLower(parts[1]), true
                }</span>
        }

        <span class="cov0" title="0">if num, err := phonenumbers.Parse(s, "ID"); err == nil &amp;&amp; phonenumbers.IsValidNumber(num) </span><span class="cov0" title="0">{
                return "phone", phonenumbers.Format(num, phonenumbers.E164), true
        }</span>

        <span class="cov0" title="0">return "", "", false</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package log

import "time"

func Any(key string, value any) LoggerContextFn <span class="cov0" title="0">{
        if l, ok := value.(Loggable); ok </span><span class="cov0" title="0">{
                value = l.AsLog()
        }</span>

        <span class="cov0" title="0">return func(ctx LoggerContext) </span><span class="cov0" title="0">{
                ctx.Any(key, value)
        }</span>

}

func Bool(key string, value bool) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Bool(key, value)
        }</span>
}

func Bytes(key string, value []byte) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Bytes(key, value)
        }</span>
}

func String(key string, value string) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.String(key, value)
        }</span>
}

func Float64(key string, value float64) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Float64(key, value)
        }</span>
}

func Int64(key string, value int64) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Int64(key, value)
        }</span>
}

func Uint64(key string, value uint64) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Uint64(key, value)
        }</span>
}

func Time(key string, value time.Time) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Time(key, value)
        }</span>
}

func Duration(key string, value time.Duration) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Duration(key, value)
        }</span>
}

func Error(key string, err error) LoggerContextFn <span class="cov0" title="0">{
        return func(lc LoggerContext) </span><span class="cov0" title="0">{
                lc.Error(key, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package logrus

import (
        "fmt"
        "time"

        "github.com/dyaksa/warehouse/pkg/log"
        "github.com/sirupsen/logrus"
)

type Level int

const (
        PanicLevel Level = iota
        FatalLevel
        ErrorLevel
        WarnLevel
        InfoLevel
        DebugLevel
        TraceLevel
)

type Opts func(*logrusLogger) error

func withLevelString(level string) int <span class="cov0" title="0">{
        switch level </span>{
        case "panic":<span class="cov0" title="0">
                return int(PanicLevel)</span>
        case "fatal":<span class="cov0" title="0">
                return int(FatalLevel)</span>
        case "error":<span class="cov0" title="0">
                return int(ErrorLevel)</span>
        case "warn", "warning":<span class="cov0" title="0">
                return int(WarnLevel)</span>
        case "info":<span class="cov0" title="0">
                return int(InfoLevel)</span>
        case "debug":<span class="cov0" title="0">
                return int(DebugLevel)</span>
        case "trace":<span class="cov0" title="0">
                return int(TraceLevel)</span>
        }
        <span class="cov0" title="0">return int(DebugLevel)</span>
}

func WithLevel(lvl string) Opts <span class="cov0" title="0">{
        return func(ll *logrusLogger) error </span><span class="cov0" title="0">{
                level := withLevelString(lvl)
                if Level(level) &gt; Level(logrus.DebugLevel) || Level(level) &lt; Level(logrus.PanicLevel) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid log level")
                }</span>

                <span class="cov0" title="0">ll.level = Level(level)
                return nil</span>
        }
}

func WithJSONFormatter() Opts <span class="cov0" title="0">{
        return func(ll *logrusLogger) error </span><span class="cov0" title="0">{
                ll.logrus.SetFormatter(&amp;logrus.JSONFormatter{})
                return nil
        }</span>
}

func WithCaller(status bool) Opts <span class="cov0" title="0">{
        return func(ll *logrusLogger) error </span><span class="cov0" title="0">{
                ll.caller = status
                return nil
        }</span>
}

type logrusLogger struct {
        logrus *logrus.Logger
        caller bool
        level  Level
}

type loggerContext struct {
        fields logrus.Fields
}

func New(opts ...Opts) (*logrusLogger, error) <span class="cov0" title="0">{
        var log = &amp;logrusLogger{
                logrus: logrus.New(),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(log); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">log.logrus.SetLevel(logrus.Level(log.level))
        log.logrus.SetReportCaller(log.caller)

        return log, nil</span>
}

func (l *logrusLogger) Info(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; InfoLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Info(msg)</span>
}

func (l *logrusLogger) Error(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; ErrorLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Error(msg)</span>
}

func (l *logrusLogger) Warn(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; WarnLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Warn(msg)</span>
}

func (l *logrusLogger) Debug(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; DebugLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Debug(msg)</span>
}

func (l *logrusLogger) Fatal(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; FatalLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Fatal(msg)</span>
}

func (l *logrusLogger) Panic(msg string, fn ...log.LoggerContextFn) <span class="cov0" title="0">{
        if l.level &gt; PanicLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.logrus.WithFields(newLoggerContext(fn...).fields).Panic(msg)</span>
}

func newLoggerContext(fn ...log.LoggerContextFn) *loggerContext <span class="cov0" title="0">{
        ctx := &amp;loggerContext{
                fields: logrus.Fields{},
        }

        for _, f := range fn </span><span class="cov0" title="0">{
                f(ctx)
        }</span>
        <span class="cov0" title="0">return ctx</span>
}

func (lc *loggerContext) Any(key string, value interface{}) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Bool(key string, value bool) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Bytes(key string, value []byte) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) String(key string, value string) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Float64(key string, value float64) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Int64(key string, value int64) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Uint64(key string, value uint64) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Time(key string, value time.Time) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Duration(key string, value time.Duration) <span class="cov0" title="0">{
        lc.fields[key] = value
}</span>

func (lc *loggerContext) Error(key string, err error) <span class="cov0" title="0">{
        lc.fields[key] = err
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package paginator

import "context"

type OffsetPaginator[T any] struct{}

func (o *OffsetPaginator[T]) Paginate(ctx context.Context, req PaginationRequest, fetcher DataFetcher[T]) (*PaginationResult[T], error) <span class="cov0" title="0">{
        req.ValidateAndSetDefault()
        offset := req.GetOffset()

        items, totalItems, err := fetcher(ctx, offset, req.Limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewPaginationResult(items, totalItems, req), nil</span>
}

func NewOffsetPaginator[T any]() Paginator[T] <span class="cov0" title="0">{
        return &amp;OffsetPaginator[T]{}
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package paginator

import "math"

const (
        DefaultPage  = 1
        DefaultLimit = 10
        MaxLimit     = 100
)

type PaginationRequest struct {
        Page  int `form:"page"`
        Limit int `form:"limit"`
}

func (pr *PaginationRequest) ValidateAndSetDefault() <span class="cov0" title="0">{
        if pr.Page &lt;= 0 </span><span class="cov0" title="0">{
                pr.Page = DefaultPage
        }</span>

        <span class="cov0" title="0">if pr.Limit &lt;= 0 </span><span class="cov0" title="0">{
                pr.Limit = DefaultLimit
        }</span>

        <span class="cov0" title="0">if pr.Limit &gt; MaxLimit </span><span class="cov0" title="0">{
                pr.Limit = MaxLimit
        }</span>
}

func (pr *PaginationRequest) GetOffset() int <span class="cov0" title="0">{
        return (pr.Page - 1) * pr.Limit
}</span>

type PaginationResult[T any] struct {
        Items      []T  `json:"items"`
        TotalItems int  `json:"total_items"`
        TotalPages int  `json:"total_pages"`
        Page       int  `json:"page"`
        Limit      int  `json:"limit"`
        HasNext    bool `json:"has_next"`
        HasPrev    bool `json:"has_prev"`
}

func NewPaginationResult[T any](items []T, totalItems int, req PaginationRequest) *PaginationResult[T] <span class="cov0" title="0">{
        if items == nil </span><span class="cov0" title="0">{
                items = make([]T, 0)
        }</span>

        <span class="cov0" title="0">totalPages := 0
        if totalItems &gt; 0 &amp;&amp; req.Limit &gt; 0 </span><span class="cov0" title="0">{
                totalPages = int(math.Ceil(float64(totalItems) / float64(req.Limit)))
        }</span>

        <span class="cov0" title="0">return &amp;PaginationResult[T]{
                Items:      items,
                TotalItems: totalItems,
                TotalPages: totalPages,
                Page:       req.Page,
                Limit:      req.Limit,
                HasNext:    req.Page &lt; totalPages,
                HasPrev:    req.Page &gt; 1 &amp;&amp; totalItems &gt; 0,
        }</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package passwordutils

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

// VerifyPassword verifies if the given password matches the stored hash.
func VerifyPassword(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package ratelimit

import (
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

type Info struct {
        Limit         uint
        RateLimited   bool
        ResetTime     time.Time
        RemainingHits uint
}

type Store interface {
        Limit(key string, c *gin.Context) Info
}

type Options struct {
        ErrorHandler   func(*gin.Context, Info)
        KeyFunc        func(*gin.Context) string
        BeforeResponse func(c *gin.Context, info Info)
}

type user struct {
        ts     int64
        tokens uint
}

type inMemoryStoreType struct {
        rate  int64
        limit uint
        data  *sync.Map
        skip  func(ctx *gin.Context) bool
}

func (i *inMemoryStoreType) Limit(key string, c *gin.Context) Info <span class="cov0" title="0">{
        var u user
        m, ok := i.data.Load(key)
        if !ok </span><span class="cov0" title="0">{
                u = user{ts: time.Now().Unix(), tokens: i.limit}
        }</span> else<span class="cov0" title="0"> {
                u = m.(user)
        }</span>
        <span class="cov0" title="0">if u.ts+i.rate &lt;= time.Now().Unix() </span><span class="cov0" title="0">{
                u.tokens = i.limit
        }</span>

        <span class="cov0" title="0">if i.skip != nil &amp;&amp; i.skip(c) </span><span class="cov0" title="0">{
                return Info{
                        Limit:         i.limit,
                        RateLimited:   false,
                        ResetTime:     time.Now().Add(time.Duration((i.rate - (time.Now().Unix() - u.ts)) * time.Second.Nanoseconds())),
                        RemainingHits: u.tokens,
                }
        }</span>

        <span class="cov0" title="0">if u.tokens &lt;= 0 </span><span class="cov0" title="0">{
                return Info{
                        Limit:         i.limit,
                        RateLimited:   true,
                        ResetTime:     time.Now().Add(time.Duration((i.rate - (time.Now().Unix() - u.ts)) * time.Second.Nanoseconds())),
                        RemainingHits: 0,
                }
        }</span>
        <span class="cov0" title="0">u.tokens--
        u.ts = time.Now().Unix()
        i.data.Store(key, u)

        return Info{
                Limit:         i.limit,
                RateLimited:   false,
                ResetTime:     time.Now().Add(time.Duration((i.rate - (time.Now().Unix() - u.ts)) * time.Second.Nanoseconds())),
                RemainingHits: u.tokens,
        }</span>
}

func clearMemoryInBackground(data *sync.Map, rate int64) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                data.Range(func(key, value any) bool </span><span class="cov0" title="0">{
                        if value.(user).ts+rate &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                                data.Delete(key)
                        }</span>
                        <span class="cov0" title="0">return true</span>
                })
                <span class="cov0" title="0">time.Sleep(time.Minute)</span>
        }
}

type InMemoryOptions struct {
        Rate  time.Duration
        Limit uint
        Skip  func(*gin.Context) bool
}

func InMemoryStore(options *InMemoryOptions) Store <span class="cov0" title="0">{
        data := &amp;sync.Map{}
        store := inMemoryStoreType{int64(options.Rate.Seconds()), options.Limit, data, options.Skip}
        go clearMemoryInBackground(data, store.rate)
        return &amp;store
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package response_error

import "github.com/gin-gonic/gin"

type errorResponseContext struct {
        ctx *gin.Context
}

type errorResponse struct {
        errorResponseContext
        message string
        status  string
}

// Msg implements ErrorResponse.
func (e *errorResponse) Msg(msg string) *errorResponse <span class="cov0" title="0">{
        e.message = msg
        return e
}</span>

// Send implements ErrorResponse.
func (e *errorResponse) Send(code int) <span class="cov0" title="0">{
        data := gin.H{
                "message": e.message,
                "status":  e.status,
        }

        e.ctx.JSON(code, data)
}</span>

// Status implements ErrorResponse.
func (e *errorResponse) Status(status string) *errorResponse <span class="cov0" title="0">{
        e.status = status
        return e
}</span>

type ErrorResponse interface {
        Msg(msg string) *errorResponse
        Status(status string) *errorResponse
        Send(code int)
}

func JSON(ctx *gin.Context) ErrorResponse <span class="cov0" title="0">{
        return &amp;errorResponse{errorResponseContext: errorResponseContext{ctx: ctx}}
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package response_success

import "github.com/gin-gonic/gin"

type successResponseContext struct {
        ctx *gin.Context
}

type successResponse struct {
        successResponseContext
        message string
        status  string
        data    any
}

// Msg implements ErrorResponse.
func (e *successResponse) Msg(msg string) *successResponse <span class="cov0" title="0">{
        e.message = msg
        return e
}</span>

// Send implements ErrorResponse.
func (e *successResponse) Send(code int) <span class="cov0" title="0">{
        data := gin.H{
                "data":    e.data,
                "message": e.message,
                "status":  e.status,
        }

        e.ctx.JSON(code, data)
}</span>

// Status implements ErrorResponse.
func (e *successResponse) Status(status string) *successResponse <span class="cov0" title="0">{
        e.status = status
        return e
}</span>

type SuccessResponse interface {
        Msg(msg string) *successResponse
        Status(status string) *successResponse
        Data(v any) *successResponse
        Send(code int)
}

func (e *successResponse) Data(v any) *successResponse <span class="cov0" title="0">{
        e.data = v
        return e
}</span>

func JSON(ctx *gin.Context) SuccessResponse <span class="cov0" title="0">{
        return &amp;successResponse{successResponseContext: successResponseContext{ctx: ctx}}
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package tokenutils

import (
        "time"

        "github.com/dyaksa/warehouse/domain"
        jwt "github.com/golang-jwt/jwt"
)

func CreateAccessToken(user *domain.User, secret string, expiry int) (string, error) <span class="cov0" title="0">{
        exp := time.Now().Add(time.Hour * time.Duration(expiry)).Unix()
        claims := &amp;domain.JwtCustomClaims{
                ID: user.ID,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: exp,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))
}</span>

func CreateRefreshAccessToken(user *domain.User, secret string, expiry int) (string, error) <span class="cov0" title="0">{
        claims := &amp;domain.JwtCustomClaims{
                ID: user.ID,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour * time.Duration(expiry)).Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))
}</span>

func IsAuthorized(requestToken string, secret string) (bool, error) <span class="cov0" title="0">{
        _, err := jwt.Parse(requestToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrSignatureInvalid
                }</span>
                <span class="cov0" title="0">return []byte(secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func ExtractIDFromToken(requestToken string, secret string) (string, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(requestToken, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, jwt.ErrInvalidKey
                }</span>

                <span class="cov0" title="0">return []byte(secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return "", jwt.ErrInvalidKey
        }</span>

        <span class="cov0" title="0">userID, ok := claims["uuid"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", jwt.ErrInvalidKey
        }</span>

        <span class="cov0" title="0">return userID, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package validationutils

import (
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/nyaruka/phonenumbers"
)

func IdentifierValidator(v *validator.Validate) error <span class="cov0" title="0">{
        return v.RegisterValidation("identifier", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                raw := strings.TrimSpace(fl.Field().String())
                if raw == "" </span><span class="cov0" title="0">{
                        return false
                }</span>
                // Cek email sederhana (re-usable validator bawaan)
                <span class="cov0" title="0">if err := validator.New().Var(raw, "email"); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                // Cek phone via libphonenumber (anggap default region "ID")
                <span class="cov0" title="0">num, err := phonenumbers.Parse(raw, "ID")
                return err == nil &amp;&amp; phonenumbers.IsValidNumber(num)</span>
        })
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package repository

import (
        "context"
        "database/sql"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type idempotencyRequestRepository struct {
        db pqsql.Client
}

// BeginKey implements domain.IdempotencyRequestRepository.
func (i *idempotencyRequestRepository) BeginKey(ctx context.Context, tx *sql.Tx, key string, endpoint string, payloadHash string) (isNew bool, err error) <span class="cov0" title="0">{
        query := sq.Insert("idempotency_requests").
                Columns("key", "endpoint", "payload_hash").Values(key, endpoint, payloadHash).
                Suffix("ON CONFLICT (key, endpoint) DO NOTHING").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">res, err := tx.ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return rowsAffected &gt; 0, nil</span>
}

// LoadIfExists implements domain.IdempotencyRequestRepository.
func (i *idempotencyRequestRepository) LoadIfExists(ctx context.Context, tx *sql.Tx, key string, endpoint string) (payloadHash string, orderID *uuid.UUID, responseJSON []byte, exists bool, err error) <span class="cov0" title="0">{
        query := sq.Select("payload_hash", "order_id", "response_body").
                From("idempotency_requests").
                Where(sq.And{
                        sq.Eq{"key": key},
                        sq.Eq{"endpoint": endpoint},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, nil, false, err
        }</span>

        <span class="cov0" title="0">var oID sql.NullString
        var respJSON []byte
        err = tx.QueryRowContext(ctx, q, args...).Scan(&amp;payloadHash, &amp;oID, &amp;respJSON)

        switch </span>{
        case err == sql.ErrNoRows:<span class="cov0" title="0">
                return "", nil, nil, false, nil</span>
        case err != nil:<span class="cov0" title="0">
                return "", nil, nil, false, err</span>
        }

        <span class="cov0" title="0">if oID.Valid </span><span class="cov0" title="0">{
                parsedID, err := uuid.Parse(oID.String)
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, nil, false, err
                }</span>
                <span class="cov0" title="0">orderID = &amp;parsedID</span>
        }

        <span class="cov0" title="0">responseJSON = respJSON

        return payloadHash, orderID, responseJSON, true, nil</span>
}

// SaveResponse implements domain.IdempotencyRequestRepository.
func (i *idempotencyRequestRepository) SaveResponse(ctx context.Context, tx *sql.Tx, key string, endpoint string, orderID uuid.UUID, responseJSON []byte) error <span class="cov0" title="0">{
        query := sq.Update("idempotency_requests").
                Set("order_id", orderID).
                Set("response_body", responseJSON).
                Where(sq.And{
                        sq.Eq{"key": key},
                        sq.Eq{"endpoint": endpoint},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        return err</span>
}

func NewIdempotencyRequestRepository(db pqsql.Client) domain.IdempotencyRequestRepository <span class="cov0" title="0">{
        return &amp;idempotencyRequestRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type movementRepository struct {
        db pqsql.Client
}

// Append implements domain.MovementRepository.
func (m *movementRepository) Append(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, typ string, qty int, refType string, refID uuid.UUID) error <span class="cov0" title="0">{
        query := squirrel.
                Insert("stock_movements").
                Columns("id", "product_id", "warehouse_id", "type", "qty", "ref_type", "ref_id").
                Values(uuid.New(), productID, warehouseID, typ, qty, refType, refID).
                PlaceholderFormat(squirrel.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        return err</span>
}

func NewMovementRepository(db pqsql.Client) domain.MovementRepository <span class="cov0" title="0">{
        return &amp;movementRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package repository

import (
        "context"
        "database/sql"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
)

type orderItemRepository struct {
        db pqsql.Client
}

func (o *orderItemRepository) BulkInsert(ctx context.Context, tx *sql.Tx, items []domain.OrderItem) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := sq.Insert("order_items").
                Columns("id", "order_id", "product_id", "qty", "price").
                PlaceholderFormat(sq.Dollar)

        for _, item := range items </span><span class="cov0" title="0">{
                query = query.Values(item.ID, item.OrderID, item.ProductID, item.Qty, item.Price)
        }</span>

        <span class="cov0" title="0">q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

func NewOrderItemRepository(db pqsql.Client) domain.OrderItemRepository <span class="cov0" title="0">{
        return &amp;orderItemRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package repository

import (
        "context"
        "database/sql"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type orderRepository struct {
        db pqsql.Client
}

// Create implements domain.OrderRepository.
func (or *orderRepository) Create(ctx context.Context, tx *sql.Tx, o *domain.Order) error <span class="cov0" title="0">{
        query := sq.Insert("orders").
                Columns("id", "user_id", "shop_id", "status", "total_amount").
                Values(o.ID, o.UserID, o.ShopID, o.Status, o.Total).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        return err</span>
}

// GetByID implements domain.OrderRepository.
func (or *orderRepository) GetByID(ctx context.Context, orderID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        query := sq.Select("id", "user_id", "shop_id", "status", "CAST(total_amount AS BIGINT) as total_amount", "created_at", "updated_at").
                From("orders").
                Where(sq.Eq{"id": orderID}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var o domain.Order
        err = or.db.Database().QueryRowContext(ctx, q, args...).
                Scan(&amp;o.ID, &amp;o.UserID, &amp;o.ShopID, &amp;o.Status, &amp;o.Total, &amp;o.CreatedAt, &amp;o.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;o, nil</span>
}

// Updatestatus implements domain.OrderRepository.
func (or *orderRepository) Updatestatus(ctx context.Context, orderID uuid.UUID, status domain.OrderStatus) error <span class="cov0" title="0">{
        query := sq.Update("orders").
                Set("status", status).
                Set("updated_at", sq.Expr("now()")).
                Where(sq.Eq{"id": orderID}).
                PlaceholderFormat(sq.Dollar)
        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = or.db.Database().ExecContext(ctx, q, args...)

        return err</span>
}

// GetByUserID implements domain.OrderRepository.
func (or *orderRepository) GetByUserID(ctx context.Context, userID uuid.UUID, limit, offset int) ([]domain.OrderListItem, int, error) <span class="cov0" title="0">{
        var orders []domain.OrderListItem
        var totalCount int

        // First, get the total count for pagination
        countQuery := sq.Select("COUNT(*)").
                From("orders").
                Where(sq.Eq{"user_id": userID}).
                PlaceholderFormat(sq.Dollar)

        countSql, countArgs, err := countQuery.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">err = or.db.Database().QueryRowContext(ctx, countSql, countArgs...).Scan(&amp;totalCount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Then get the paginated orders with item count
        <span class="cov0" title="0">query := sq.Select(
                "o.id",
                "CAST(o.total_amount AS BIGINT) as total_amount",
                "o.status",
                "COUNT(oi.id) as item_count",
                "o.reservation_expires_at",
                "o.created_at",
        ).
                From("orders o").
                LeftJoin("order_items oi ON oi.order_id = o.id").
                Where(sq.Eq{"o.user_id": userID}).
                GroupBy("o.id", "o.total_amount", "o.status", "o.reservation_expires_at", "o.created_at").
                OrderBy("o.created_at DESC").
                Limit(uint64(limit)).
                Offset(uint64(offset)).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">rows, err := or.db.Database().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var order domain.OrderListItem
                var reservationExpiresAt sql.NullTime

                err := rows.Scan(
                        &amp;order.ID,
                        &amp;order.Total,
                        &amp;order.Status,
                        &amp;order.ItemCount,
                        &amp;reservationExpiresAt,
                        &amp;order.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov0" title="0">if reservationExpiresAt.Valid </span><span class="cov0" title="0">{
                        order.ReservationExpiresAt = &amp;reservationExpiresAt.Time
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return orders, totalCount, nil</span>
}

func NewOrderRepository(db pqsql.Client) domain.OrderRepository <span class="cov0" title="0">{
        return &amp;orderRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package repository

import (
        "context"
        "fmt"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type productRepository struct {
        db pqsql.Client
}

func (p *productRepository) RetrieveAll(ctx context.Context, limit, offset int) ([]domain.RetrieveProduct, error) <span class="cov0" title="0">{
        var results []domain.RetrieveProduct
        avail := sq.Select("s.product_id", "SUM(s.on_hand - s.reserved) AS available", "w.name AS warehouse_name", "w.shop_id AS shop_id").
                From("product_stock s").
                Join("warehouses w ON w.id = s.warehouse_id").
                GroupBy("s.product_id", "w.name", "w.shop_id")

        availSql, availArgs, err := avail.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>

        <span class="cov0" title="0">list := sq.Select("p.id", "p.sku", "p.name", "COALESCE(a.available,0) AS available", "a.warehouse_name").
                From("products p").
                LeftJoin("("+availSql+") AS a ON a.product_id = p.id").
                OrderBy("p.created_at DESC", "p.id DESC").
                Limit(uint64(limit)).
                Offset(uint64(offset))

        q, args, err := list.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>

        <span class="cov0" title="0">args = append(args, availArgs...)

        rows, err := p.db.Database().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var r domain.RetrieveProduct
                if err := rows.Scan(&amp;r.ID, &amp;r.SKU, &amp;r.Name, &amp;r.Available, &amp;r.WarehouseName); err != nil </span><span class="cov0" title="0">{
                        return results, err
                }</span>
                <span class="cov0" title="0">results = append(results, r)</span>
        }
        <span class="cov0" title="0">return results, nil</span>
}

// Create implements domain.ProductRepository.
func (p *productRepository) Create(ctx context.Context, product *domain.Product) (uuid.UUID, error) <span class="cov0" title="0">{
        var id uuid.UUID

        query := sq.Insert("products").
                Columns("sku", "name").
                Values(&amp;product.SKU, &amp;product.Name).
                Suffix("RETURNING id").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">if err := p.db.Database().QueryRowContext(ctx, q, args...).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                fmt.Println("err", err)
                return id, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func NewProductRepository(db pqsql.Client) domain.ProductRepository <span class="cov0" title="0">{
        return &amp;productRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package repository

import (
        "context"
        "database/sql"
        "time"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type productStockRepository struct {
        db pqsql.Client
}

// ReleaseStock implements domain.ProductStockRepository.
func (p *productStockRepository) ReleaseStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        query := sq.Update("product_stock").
                Set("reserved", sq.Expr("reserved - ?", quantity)).
                Set("updated_at", "now()").
                Where(sq.And{
                        sq.Eq{"product_id": productID},
                        sq.Eq{"warehouse_id": warehouseID},
                }).PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TryReserveStock implements domain.ProductStockRepository.
func (p *productStockRepository) TryReserveStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) (bool, error) <span class="cov0" title="0">{
        query := sq.Update("product_stock").
                Set("reserved", sq.Expr("reserved + ?", quantity)).
                Set("updated_at", "now()").
                Where(sq.And{
                        sq.Eq{"product_id": productID},
                        sq.Eq{"warehouse_id": warehouseID},
                        sq.Expr("(on_hand - reserved) &gt;= ?", quantity),
                }).
                Suffix("RETURNING id").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">var id uuid.UUID
        err = tx.QueryRowContext(ctx, q, args...).Scan(&amp;id)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// CommitStock implements domain.ProductStockRepository.
func (p *productStockRepository) CommitStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        query := sq.Update("product_stock").
                Set("on_hand", sq.Expr("on_hand - ?", quantity)).
                Set("reserved", sq.Expr("reserved - ?", quantity)).
                Set("updated_at", "now()").
                Where(sq.And{
                        sq.Eq{"product_id": productID},
                        sq.Eq{"warehouse_id": warehouseID},
                }).PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// AddStock implements domain.ProductStockRepository.
func (p *productStockRepository) AddStock(ctx context.Context, tx *sql.Tx, productID uuid.UUID, warehouseID uuid.UUID, quantity int32) error <span class="cov0" title="0">{
        // First try to update existing record
        updateQuery := sq.Update("product_stock").
                Set("on_hand", sq.Expr("on_hand + ?", quantity)).
                Set("updated_at", "now()").
                Where(sq.And{
                        sq.Eq{"product_id": productID},
                        sq.Eq{"warehouse_id": warehouseID},
                }).
                Suffix("RETURNING id").
                PlaceholderFormat(sq.Dollar)

        q, args, err := updateQuery.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var id uuid.UUID
        err = tx.QueryRowContext(ctx, q, args...).Scan(&amp;id)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Product doesn't exist in this warehouse, create new record
                insertQuery := sq.Insert("product_stock").
                        Columns("id", "product_id", "warehouse_id", "on_hand", "reserved", "updated_at").
                        Values(uuid.New(), productID, warehouseID, quantity, 0, "now()").
                        PlaceholderFormat(sq.Dollar)

                iq, iargs, err := insertQuery.ToSql()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, iq, iargs...)
                return err</span>
        }

        <span class="cov0" title="0">return err</span>
}

func (p *productStockRepository) Create(ctx context.Context, productStock *domain.ProductStock) (uuid.UUID, error) <span class="cov0" title="0">{
        var id uuid.UUID
        query := sq.Insert("product_stock").
                Columns("product_id", "warehouse_id", "on_hand", "updated_at").
                Values(&amp;productStock.ProductID, &amp;productStock.WarehouseID, &amp;productStock.OnHand, time.Now()).
                Suffix("RETURNING id").PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">if err := p.db.Database().QueryRowContext(ctx, q, args...).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func NewProductStockRepository(db pqsql.Client) domain.ProductStockRepository <span class="cov0" title="0">{
        return &amp;productStockRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package repository

import (
        "context"
        "database/sql"
        "time"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type reservationRepository struct {
        db pqsql.Client
}

// CreateMany implements domain.ReservationRepository.
func (r *reservationRepository) CreateMany(ctx context.Context, tx *sql.Tx, reservations []domain.Reservation) error <span class="cov0" title="0">{
        query := sq.Insert("stock_reservations").
                Columns("id", "order_id", "product_id", "warehouse_id", "qty", "status", "expires_at").
                PlaceholderFormat(sq.Dollar)

        for _, res := range reservations </span><span class="cov0" title="0">{
                query = query.Values(res.ID, res.OrderID, res.ProductID, res.WarehouseID, res.Qty, res.Status, res.ExpiresAt)
        }</span>

        <span class="cov0" title="0">q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        return err</span>
}

// MarkExpired implements domain.ReservationRepository.
func (r *reservationRepository) MarkExpired(ctx context.Context, tx *sql.Tx, id uuid.UUID) error <span class="cov0" title="0">{
        query := sq.Update("stock_reservations").
                Set("status", "EXPIRED").
                Set("updated_at", time.Now()).
                Where(sq.And{
                        sq.Eq{"id": id},
                        sq.Eq{"status": "PENDING"},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)

        return err</span>
}

// PendingCountByOrder implements domain.ReservationRepository.
func (r *reservationRepository) PendingCountByOrder(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) (int, error) <span class="cov0" title="0">{
        var n int
        query := sq.Select("COUNT(*)").
                From("stock_reservations").
                Where(sq.And{
                        sq.Eq{"order_id": orderID},
                        sq.Eq{"status": "PENDING"},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">err = tx.QueryRowContext(ctx, q, args...).Scan(&amp;n)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return n, nil</span>
}

// PickExpiredForUpdate implements domain.ReservationRepository.
func (r *reservationRepository) PickExpiredForUpdate(ctx context.Context, tx *sql.Tx, limit int) ([]domain.Reservation, error) <span class="cov0" title="0">{
        query := sq.Select("id", "order_id", "product_id", "warehouse_id", "qty", "status", "expires_at").
                From("stock_reservations").
                Where(sq.And{
                        sq.Eq{"status": "PENDING"},
                        sq.Expr("expires_at &lt;= now()"),
                }).
                Limit(uint64(limit)).
                Suffix("FOR UPDATE SKIP LOCKED").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reservations []domain.Reservation
        for rows.Next() </span><span class="cov0" title="0">{
                var res domain.Reservation
                err := rows.Scan(&amp;res.ID, &amp;res.OrderID, &amp;res.ProductID, &amp;res.WarehouseID,
                        &amp;res.Qty, &amp;res.Status, &amp;res.ExpiresAt)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">reservations = append(reservations, res)</span>
        }

        <span class="cov0" title="0">return reservations, rows.Err()</span>
}

// Retrieve implements domain.ReservationRepository.
func (r *reservationRepository) Retrieve(ctx context.Context, tx *sql.Tx, id uuid.UUID) (*domain.Reservation, error) <span class="cov0" title="0">{
        var reservation domain.Reservation
        query := sq.Select("id", "order_id", "product_id", "warehouse_id", "qty", "status", "expires_at").
                From("stock_reservations").
                Where(sq.Eq{"id": id}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = tx.QueryRowContext(ctx, q, args...).
                Scan(&amp;reservation.ID, &amp;reservation.OrderID, &amp;reservation.ProductID, &amp;reservation.WarehouseID,
                        &amp;reservation.Qty, &amp;reservation.Status, &amp;reservation.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;reservation, nil</span>
}

// MarkCommitted implements domain.ReservationRepository.
func (r *reservationRepository) MarkCommitted(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error <span class="cov0" title="0">{
        query := sq.Update("stock_reservations").
                Set("status", "COMMITTED").
                Set("updated_at", time.Now()).
                Where(sq.And{
                        sq.Eq{"order_id": orderID},
                        sq.Eq{"status": "PENDING"},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// MarkReleased implements domain.ReservationRepository.
func (r *reservationRepository) MarkReleased(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) error <span class="cov0" title="0">{
        query := sq.Update("stock_reservations").
                Set("status", "RELEASED").
                Set("updated_at", time.Now()).
                Where(sq.And{
                        sq.Eq{"order_id": orderID},
                        sq.Eq{"status": "PENDING"},
                }).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// GetByOrderID implements domain.ReservationRepository.
func (r *reservationRepository) GetByOrderID(ctx context.Context, tx *sql.Tx, orderID uuid.UUID) ([]domain.Reservation, error) <span class="cov0" title="0">{
        query := sq.Select("id", "order_id", "product_id", "warehouse_id", "qty", "status", "expires_at").
                From("stock_reservations").
                Where(sq.Eq{"order_id": orderID}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, err := tx.QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var reservations []domain.Reservation
        for rows.Next() </span><span class="cov0" title="0">{
                var res domain.Reservation
                err := rows.Scan(&amp;res.ID, &amp;res.OrderID, &amp;res.ProductID, &amp;res.WarehouseID,
                        &amp;res.Qty, &amp;res.Status, &amp;res.ExpiresAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">reservations = append(reservations, res)</span>
        }

        <span class="cov0" title="0">return reservations, rows.Err()</span>
}

func NewReservationRepository(db pqsql.Client) domain.ReservationRepository <span class="cov0" title="0">{
        return &amp;reservationRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package repository

import (
        "context"
        "time"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type shopRepository struct {
        db pqsql.Client
}

// Create implements domain.ShopRepository.
func (s *shopRepository) Create(ctx context.Context, shop *domain.Shop) (uuid.UUID, error) <span class="cov0" title="0">{
        var id uuid.UUID

        query := sq.Insert("shops").
                Columns("name", "created_at").
                Values(&amp;shop.Name, time.Now()).
                Suffix("RETURNING id").PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">if err := s.db.Database().QueryRowContext(ctx, q, args...).Scan(&amp;id); err != nil </span><span class="cov0" title="0">{
                return id, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

// Delete implements domain.ShopRepository.
func (s *shopRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        query := sq.Delete("shops").Where(sq.Eq{"id": id}).PlaceholderFormat(sq.Dollar)
        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = s.db.Database().ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Retrieve implements domain.ShopRepository.
func (s *shopRepository) Retrieve(ctx context.Context, id uuid.UUID) (*domain.Shop, error) <span class="cov0" title="0">{
        var shop domain.Shop

        query := sq.Select("id", "name", "created_at").
                From("shops").
                Where(sq.Eq{"id": id}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.db.Database().QueryRowContext(ctx, q, args...).Scan(&amp;shop.ID, &amp;shop.Name, &amp;shop.CreatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;shop, nil</span>
}

// Update implements domain.ShopRepository.
func (s *shopRepository) Update(ctx context.Context, shop *domain.Shop) error <span class="cov0" title="0">{
        query := sq.Update("shops").Set("name", shop.Name).Where(sq.Eq{"id": shop.ID}).PlaceholderFormat(sq.Dollar)
        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = s.db.Database().ExecContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewShopRepository(db pqsql.Client) domain.ShopRepository <span class="cov0" title="0">{
        return &amp;shopRepository{
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
)

type useRepository struct {
        database pqsql.Client
}

// GetMailOrPhone implements domain.UserRepository.
func (ur *useRepository) GetMailOrPhone(ctx context.Context, email_bidx string, phone_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        if fn != nil </span><span class="cov0" title="0">{
                fn(&amp;user)
        }</span>

        <span class="cov0" title="0">query := `SELECT id, email, phone FROM users WHERE email_bidx = $1 OR phone_bidx = $2 LIMIT 1`
        err := ur.database.Database().QueryRowContext(ctx, query, email_bidx, phone_bidx).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone,
        )

        switch </span>{
        case errors.Is(err, sql.ErrNoRows):<span class="cov0" title="0">
                return nil, errors.New("user not found")</span>
        case err != nil:<span class="cov0" title="0">
                return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (ur *useRepository) CreateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        query := `INSERT INTO users (email, email_bidx, phone, phone_bidx, password_hash) VALUES ($1, $2, $3, $4, $5)`

        _, err := ur.database.Database().Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, query, user.Email, user.EmailBidx, user.Phone, user.PhoneBidx, user.PasswordHash)
                return nil, err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error inserting user:", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (ur *useRepository) GetUserByPhone(ctx context.Context, phone_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User

        if fn != nil </span><span class="cov0" title="0">{
                fn(&amp;user)
        }</span>

        <span class="cov0" title="0">query := `SELECT id, email, phone FROM users WHERE phone_bidx = $1 LIMIT 1`
        err := ur.database.Database().QueryRowContext(ctx, query, nil, &amp;domain.User{}, phone_bidx).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.Phone,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (ur *useRepository) GetUserByEmail(ctx context.Context, email_bidx string, fn func(data *domain.User)) (*domain.User, error) <span class="cov0" title="0">{
        var existingUser domain.User

        if fn != nil </span><span class="cov0" title="0">{
                fn(&amp;existingUser)
        }</span>

        <span class="cov0" title="0">query := `SELECT id, email, phone FROM users WHERE email_bidx = $1 LIMIT 1`
        err := ur.database.Database().QueryRowContext(ctx, query, email_bidx).Scan(
                &amp;existingUser.ID, &amp;existingUser.Email, &amp;existingUser.Phone,
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error fetching user by email:", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;existingUser, nil</span>
}

func NewUserRepository(db pqsql.Client) domain.UserRepository <span class="cov0" title="0">{
        return &amp;useRepository{
                database: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package repository

import (
        "context"
        "database/sql"
        "errors"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type warehouseRepository struct {
        db pqsql.Client
}

// Pick implements domain.WarehouseRepository.
func (wr *warehouseRepository) Pick(ctx context.Context, tx *sql.Tx, productID uuid.UUID, qty int, shopID uuid.UUID) (warehouseID uuid.UUID, err error) <span class="cov0" title="0">{
        query := sq.Select("ps.warehouse_id").
                From("product_stock ps").
                Join("warehouses w ON w.id = ps.warehouse_id").
                Where(sq.And{
                        sq.Eq{"ps.product_id": productID},
                        sq.Eq{"w.shop_id": shopID},
                        sq.Expr("(ps.on_hand - ps.reserved) &gt;= ?", qty),
                        sq.Eq{"w.is_active": true},
                }).
                GroupBy("ps.warehouse_id", "ps.product_id", "w.is_active").
                OrderBy("SUM(ps.on_hand - ps.reserved) DESC", "ps.warehouse_id ASC").
                Limit(1).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov0" title="0">err = tx.QueryRowContext(ctx, q, args...).Scan(&amp;warehouseID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return uuid.Nil, domain.ErrOutOfStock
                }</span>
                <span class="cov0" title="0">return uuid.Nil, err</span>
        }

        <span class="cov0" title="0">return warehouseID, nil</span>
}

// Delete implements domain.WarehouseRepository.
func (wr *warehouseRepository) Delete(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := wr.db.Database().ExecContext(ctx, "DELETE FROM warehouses WHERE id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Retrieve implements domain.WarehouseRepository.
func (wr *warehouseRepository) Retrieve(ctx context.Context, id uuid.UUID) (*domain.WareHouse, error) <span class="cov0" title="0">{
        var w domain.WareHouse
        err := wr.db.Database().QueryRowContext(ctx, "SELECT id, shop_id, name, is_active, created_at FROM warehouses WHERE id = $1", id).Scan(&amp;w.ID, &amp;w.ShopID, &amp;w.Name, &amp;w.IsActive, &amp;w.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

// Update implements domain.WarehouseRepository.
func (wr *warehouseRepository) Update(ctx context.Context, w *domain.WareHouse) error <span class="cov0" title="0">{
        _, err := wr.db.Database().ExecContext(ctx, "UPDATE warehouses SET shop_id = $2, name = $3, is_active = $4 WHERE id = $1", w.ID, w.ShopID, w.Name, w.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Create implements domain.WarehouseRepository.
func (wr *warehouseRepository) Create(ctx context.Context, w *domain.WareHouse) error <span class="cov0" title="0">{
        _, err := wr.db.Database().Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov0" title="0">{
                query := `INSERT INTO warehouses (shop_id, name, is_active, created_at) VALUES ($1, $2, $3, now())`
                _, err := tx.ExecContext(ctx, query, w.ShopID, w.Name, w.IsActive)
                return nil, err
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetByShopID implements domain.WarehouseRepository.
func (wr *warehouseRepository) GetByShopID(ctx context.Context, shopID uuid.UUID) ([]domain.WareHouse, error) <span class="cov0" title="0">{
        query := `SELECT id, shop_id, name, is_active, created_at FROM warehouses WHERE shop_id = $1 ORDER BY created_at DESC`
        rows, err := wr.db.Database().QueryContext(ctx, query, shopID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var warehouses []domain.WareHouse
        for rows.Next() </span><span class="cov0" title="0">{
                var w domain.WareHouse
                err := rows.Scan(&amp;w.ID, &amp;w.ShopID, &amp;w.Name, &amp;w.IsActive, &amp;w.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">warehouses = append(warehouses, w)</span>
        }

        <span class="cov0" title="0">return warehouses, nil</span>
}

// SetActive implements domain.WarehouseRepository.
func (wr *warehouseRepository) SetActive(ctx context.Context, id uuid.UUID, isActive bool) error <span class="cov0" title="0">{
        _, err := wr.db.Database().ExecContext(ctx, "UPDATE warehouses SET is_active = $2 WHERE id = $1", id, isActive)
        return err
}</span>

func NewWarehouseRepository(db pqsql.Client) domain.WarehouseRepository <span class="cov0" title="0">{
        return &amp;warehouseRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package repository

import (
        "context"
        "database/sql"

        sq "github.com/Masterminds/squirrel"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type warehouseTransferRepository struct {
        db pqsql.Client
}

// Create implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) Create(ctx context.Context, tx *sql.Tx, transfer *domain.WarehouseTransfer) error <span class="cov0" title="0">{
        query := sq.Insert("warehouse_transfers").
                Columns("id", "from_warehouse_id", "to_warehouse_id", "status", "created_at").
                Values(transfer.ID, transfer.FromWarehouseID, transfer.ToWarehouseID, transfer.Status, "now()").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// GetByID implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) GetByID(ctx context.Context, id uuid.UUID) (*domain.WarehouseTransfer, error) <span class="cov0" title="0">{
        query := sq.Select("id", "from_warehouse_id", "to_warehouse_id", "status", "created_at").
                From("warehouse_transfers").
                Where(sq.Eq{"id": id}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var transfer domain.WarehouseTransfer
        err = wtr.db.Database().QueryRowContext(ctx, q, args...).Scan(
                &amp;transfer.ID,
                &amp;transfer.FromWarehouseID,
                &amp;transfer.ToWarehouseID,
                &amp;transfer.Status,
                &amp;transfer.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Load items
        <span class="cov0" title="0">items, err := wtr.GetItemsByTransferID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">transfer.Items = items

        return &amp;transfer, nil</span>
}

// UpdateStatus implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) UpdateStatus(ctx context.Context, tx *sql.Tx, id uuid.UUID, status domain.TransferStatus) error <span class="cov0" title="0">{
        query := sq.Update("warehouse_transfers").
                Set("status", status).
                Where(sq.Eq{"id": id}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// GetByWarehouse implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) GetByWarehouse(ctx context.Context, warehouseID uuid.UUID, limit, offset int) ([]domain.WarehouseTransfer, int, error) <span class="cov0" title="0">{
        // Get total count
        countQuery := sq.Select("COUNT(*)").
                From("warehouse_transfers").
                Where(sq.Or{
                        sq.Eq{"from_warehouse_id": warehouseID},
                        sq.Eq{"to_warehouse_id": warehouseID},
                }).
                PlaceholderFormat(sq.Dollar)

        cq, cargs, err := countQuery.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">var total int
        err = wtr.db.Database().QueryRowContext(ctx, cq, cargs...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Get transfers
        <span class="cov0" title="0">query := sq.Select("id", "from_warehouse_id", "to_warehouse_id", "status", "created_at").
                From("warehouse_transfers").
                Where(sq.Or{
                        sq.Eq{"from_warehouse_id": warehouseID},
                        sq.Eq{"to_warehouse_id": warehouseID},
                }).
                OrderBy("created_at DESC").
                Limit(uint64(limit)).
                Offset(uint64(offset)).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">rows, err := wtr.db.Database().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var transfers []domain.WarehouseTransfer
        for rows.Next() </span><span class="cov0" title="0">{
                var transfer domain.WarehouseTransfer
                err := rows.Scan(
                        &amp;transfer.ID,
                        &amp;transfer.FromWarehouseID,
                        &amp;transfer.ToWarehouseID,
                        &amp;transfer.Status,
                        &amp;transfer.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">transfers = append(transfers, transfer)</span>
        }

        <span class="cov0" title="0">return transfers, total, nil</span>
}

// GetActiveTransfersByWarehouse implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) GetActiveTransfersByWarehouse(ctx context.Context, warehouseID uuid.UUID) ([]domain.WarehouseTransfer, error) <span class="cov0" title="0">{
        query := sq.Select("id", "from_warehouse_id", "to_warehouse_id", "status", "created_at").
                From("warehouse_transfers").
                Where(sq.And{
                        sq.Or{
                                sq.Eq{"from_warehouse_id": warehouseID},
                                sq.Eq{"to_warehouse_id": warehouseID},
                        },
                        sq.Eq{"status": []domain.TransferStatus{
                                domain.TransferStatusRequested,
                                domain.TransferStatusApproved,
                                domain.TransferStatusInTransit,
                        }},
                }).
                OrderBy("created_at DESC").
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, err := wtr.db.Database().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var transfers []domain.WarehouseTransfer
        for rows.Next() </span><span class="cov0" title="0">{
                var transfer domain.WarehouseTransfer
                err := rows.Scan(
                        &amp;transfer.ID,
                        &amp;transfer.FromWarehouseID,
                        &amp;transfer.ToWarehouseID,
                        &amp;transfer.Status,
                        &amp;transfer.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">transfers = append(transfers, transfer)</span>
        }

        <span class="cov0" title="0">return transfers, nil</span>
}

// CreateItems implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) CreateItems(ctx context.Context, tx *sql.Tx, items []domain.WarehouseTransferItem) error <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := sq.Insert("warehouse_transfer_items").
                Columns("id", "transfer_id", "product_id", "qty")

        for _, item := range items </span><span class="cov0" title="0">{
                query = query.Values(item.ID, item.TransferID, item.ProductID, item.Qty)
        }</span>

        <span class="cov0" title="0">query = query.PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, q, args...)
        return err</span>
}

// GetItemsByTransferID implements domain.WarehouseTransferRepository.
func (wtr *warehouseTransferRepository) GetItemsByTransferID(ctx context.Context, transferID uuid.UUID) ([]domain.WarehouseTransferItem, error) <span class="cov0" title="0">{
        query := sq.Select("id", "transfer_id", "product_id", "qty").
                From("warehouse_transfer_items").
                Where(sq.Eq{"transfer_id": transferID}).
                PlaceholderFormat(sq.Dollar)

        q, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rows, err := wtr.db.Database().QueryContext(ctx, q, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var items []domain.WarehouseTransferItem
        for rows.Next() </span><span class="cov0" title="0">{
                var item domain.WarehouseTransferItem
                err := rows.Scan(&amp;item.ID, &amp;item.TransferID, &amp;item.ProductID, &amp;item.Qty)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func NewWarehouseTransferRepository(db pqsql.Client) domain.WarehouseTransferRepository <span class="cov0" title="0">{
        return &amp;warehouseTransferRepository{db: db}
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package usecase

import (
        "context"
        "errors"

        "github.com/dyaksa/warehouse/bootstrap"
        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/crypto"
        "github.com/dyaksa/warehouse/pkg/helper"
        "github.com/dyaksa/warehouse/pkg/passwordutils"
        "github.com/dyaksa/warehouse/pkg/tokenutils"
)

type authUsecase struct {
        userRepo domain.UserRepository
        crypto   crypto.Crypto
        env      *bootstrap.Env
}

// Login implements domain.AuthUsecase.
func (a *authUsecase) Login(ctx context.Context, payload domain.AuthLoginRequest) (string, error) <span class="cov8" title="1">{
        _, norm, ok := helper.NormalizeIdentifier(payload.Identifier)
        if !ok </span><span class="cov8" title="1">{
                return "", errors.New("invalid identifier format")
        }</span>

        <span class="cov8" title="1">existsUser, err := a.userRepo.GetMailOrPhone(ctx, a.crypto.HashString(norm), a.crypto.HashString(norm), func(data *domain.User) </span><span class="cov8" title="1">{
                data.Email = a.crypto.Decrypt("")
                data.Phone = a.crypto.Decrypt("")
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">accessToken, err := tokenutils.CreateAccessToken(existsUser, a.env.JwtSecret, a.env.JwtExpiry)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return accessToken, nil</span>
}

// Register implements domain.AuthUsecase.
func (a *authUsecase) Register(ctx context.Context, payload domain.AuthRegisterRequest) (domain.User, error) <span class="cov8" title="1">{
        var user domain.User
        user.Email = a.crypto.Encrypt(payload.Email)
        user.Phone = a.crypto.Encrypt(payload.MustFormattedPhone())

        passwordHash, err := passwordutils.HashPassword(payload.Password)
        if err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>

        <span class="cov8" title="1">user.PasswordHash = passwordHash
        if err := a.crypto.BindHeap(&amp;user); err != nil </span><span class="cov0" title="0">{
                return user, err
        }</span>

        <span class="cov8" title="1">user.PhoneBidx = a.crypto.HashString(payload.MustFormattedPhone())
        err = a.userRepo.CreateUser(ctx, &amp;user)
        if err != nil </span><span class="cov8" title="1">{
                return user, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func NewAuthUsecase(
        userRepo domain.UserRepository,
        crypto crypto.Crypto,
        env *bootstrap.Env,
) domain.AuthUsecase <span class="cov8" title="1">{
        return &amp;authUsecase{
                userRepo: userRepo,
                crypto:   crypto,
                env:      env,
        }
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package usecase

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "time"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/dyaksa/warehouse/pkg/paginator"
        "github.com/google/uuid"
)

type orderUsecase struct {
        db                 pqsql.Database
        orderRepo          domain.OrderRepository
        idemRepo           domain.IdempotencyRequestRepository
        orderItemRepo      domain.OrderItemRepository
        reservationRepo    domain.ReservationRepository
        movementRepository domain.MovementRepository
        productStockRepo   domain.ProductStockRepository
        pickWarehouseRepo  domain.WarehouseRepository
}

func (o *orderUsecase) Checkout(ctx context.Context, input domain.CheckoutInput) (*domain.CheckoutOutput, error) <span class="cov8" title="1">{
        if len(input.Items) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("order must contain at least one item")
        }</span>

        // Handle TTL configuration - prioritize ReservationMinutes for API convenience
        <span class="cov8" title="1">if input.ReservationMinutes &gt; 0 </span><span class="cov8" title="1">{
                input.ReservationTTL = time.Duration(input.ReservationMinutes) * time.Minute
        }</span> else<span class="cov0" title="0"> if input.ReservationTTL &lt;= 0 </span><span class="cov0" title="0">{
                input.ReservationTTL = 15 * time.Minute // Default to 15 minutes
        }</span>

        <span class="cov8" title="1">out := &amp;domain.CheckoutOutput{}

        _, err := o.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov8" title="1">{
                if input.IdemKey != "" </span><span class="cov8" title="1">{
                        isNew, err := o.idemRepo.BeginKey(ctx, tx, input.IdemKey, "checkout", input.PayloadHash)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if !isNew </span><span class="cov0" title="0">{
                                payloadHash, orderID, responseJSON, exists, err := o.idemRepo.LoadIfExists(ctx, tx, input.IdemKey, "checkout")
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                                        return nil, domain.ErrIdempotencyConflict
                                }</span>

                                <span class="cov0" title="0">if payloadHash != input.PayloadHash </span><span class="cov0" title="0">{
                                        return nil, domain.ErrIdempotencyConflict
                                }</span>

                                <span class="cov0" title="0">if orderID != nil &amp;&amp; len(responseJSON) &gt; 0 </span><span class="cov0" title="0">{
                                        var existingOut domain.CheckoutOutput
                                        if err = json.Unmarshal(responseJSON, &amp;existingOut); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">*out = existingOut
                                        return out, nil</span>
                                }
                        }
                }

                <span class="cov8" title="1">shopId, err := uuid.Parse(input.ShopID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid shop ID format")
                }</span>

                <span class="cov8" title="1">userId, err := uuid.Parse(input.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid user ID format")
                }</span>

                <span class="cov8" title="1">var total int64
                productValidations := make(map[string]bool)

                for _, item := range input.Items </span><span class="cov8" title="1">{
                        if item.Qty &lt;= 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("item quantity must be greater than 0")
                        }</span>
                        <span class="cov8" title="1">if item.Price &lt;= 0 </span><span class="cov0" title="0">{
                                return nil, errors.New("item price must be greater than 0")
                        }</span>

                        <span class="cov8" title="1">productId, err := uuid.Parse(item.ProductID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("invalid product ID format: " + item.ProductID)
                        }</span>

                        <span class="cov8" title="1">if productValidations[item.ProductID] </span><span class="cov0" title="0">{
                                return nil, errors.New("duplicate product in order: " + item.ProductID)
                        }</span>
                        <span class="cov8" title="1">productValidations[item.ProductID] = true

                        _, err = o.pickWarehouseRepo.Pick(ctx, tx, productId, item.Qty, shopId)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, domain.ErrOutOfStock) </span><span class="cov0" title="0">{
                                        return nil, errors.New("insufficient stock for product: " + item.ProductID)
                                }</span>
                                <span class="cov0" title="0">return nil, err</span>
                        }

                        <span class="cov8" title="1">total += int64(item.Qty) * item.Price</span>
                }

                // Step 2: Create order
                <span class="cov8" title="1">order := &amp;domain.Order{
                        ID:            uuid.New(),
                        ShopID:        shopId,
                        UserID:        userId,
                        Total:         total,
                        Status:        domain.StatusAwaitingPayment,
                        ReservedUntil: &amp;time.Time{},
                }

                if err = o.orderRepo.Create(ctx, tx, order); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var orderItems []domain.OrderItem
                for _, item := range input.Items </span><span class="cov8" title="1">{
                        productId, _ := uuid.Parse(item.ProductID)

                        orderItem := domain.OrderItem{
                                ID:        uuid.New(),
                                OrderID:   order.ID,
                                ProductID: productId,
                                Qty:       item.Qty,
                                Price:     item.Price,
                        }
                        orderItems = append(orderItems, orderItem)
                }</span>

                <span class="cov8" title="1">if err = o.orderItemRepo.BulkInsert(ctx, tx, orderItems); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">reservationExpiry := time.Now().Add(input.ReservationTTL)
                var reservations []domain.Reservation

                for _, item := range input.Items </span><span class="cov8" title="1">{
                        productId, _ := uuid.Parse(item.ProductID)

                        warehouseId, err := o.pickWarehouseRepo.Pick(ctx, tx, productId, item.Qty, shopId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">stockReserved, err := o.productStockRepo.TryReserveStock(ctx, tx, productId, warehouseId, int32(item.Qty))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if !stockReserved </span><span class="cov0" title="0">{
                                return nil, domain.ErrOutOfStock
                        }</span>

                        <span class="cov8" title="1">reservation := domain.Reservation{
                                ID:          uuid.New(),
                                OrderID:     order.ID,
                                ProductID:   productId,
                                WarehouseID: warehouseId,
                                Qty:         item.Qty,
                                Status:      domain.ResvPending,
                                ExpiresAt:   reservationExpiry,
                        }
                        reservations = append(reservations, reservation)

                        if err = o.movementRepository.Append(ctx, tx, productId, warehouseId, "RESERVE", item.Qty, "ORDER_CHECKOUT", order.ID); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">if err = o.reservationRepo.CreateMany(ctx, tx, reservations); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">order.ReservedUntil = &amp;reservationExpiry

                out.OrderID = order.ID
                out.Total = order.Total
                out.Status = string(order.Status)
                out.ReservationExpiresAt = reservationExpiry

                if input.IdemKey != "" </span><span class="cov8" title="1">{
                        responseJSON, err := json.Marshal(out)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if err = o.idemRepo.SaveResponse(ctx, tx, input.IdemKey, "checkout", out.OrderID, responseJSON); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">return out, nil</span>
        })

        <span class="cov8" title="1">return out, err</span>
}

// ConfirmPayment implements domain.OrderUsecase.
func (o *orderUsecase) ConfirmPayment(ctx context.Context, orderID uuid.UUID) error <span class="cov0" title="0">{
        _, err := o.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov0" title="0">{
                // 1. Get order details
                order, err := o.orderRepo.GetByID(ctx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. Validate order status
                <span class="cov0" title="0">if order.Status != domain.StatusAwaitingPayment </span><span class="cov0" title="0">{
                        return nil, errors.New("order is not in awaiting payment status")
                }</span>

                // 3. Get all pending reservations for this order
                <span class="cov0" title="0">reservations, err := o.reservationRepo.GetByOrderID(ctx, tx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if len(reservations) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("no reservations found for order")
                }</span>

                // 4. Check if reservations are still valid (not expired)
                <span class="cov0" title="0">now := time.Now()
                for _, reservation := range reservations </span><span class="cov0" title="0">{
                        if reservation.Status != domain.ResvPending </span><span class="cov0" title="0">{
                                return nil, errors.New("reservation is not in pending status")
                        }</span>
                        <span class="cov0" title="0">if reservation.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                                return nil, errors.New("reservation has expired")
                        }</span>
                }

                // 5. Commit stock for all reservations
                <span class="cov0" title="0">for _, reservation := range reservations </span><span class="cov0" title="0">{
                        // Commit the stock (reduce on_hand, reduce reserved)
                        if err := o.productStockRepo.CommitStock(ctx, tx, reservation.ProductID, reservation.WarehouseID, int32(reservation.Qty)); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Log stock movement
                        <span class="cov0" title="0">if err := o.movementRepository.Append(ctx, tx, reservation.ProductID, reservation.WarehouseID,
                                "COMMIT", reservation.Qty, "ORDER_PAYMENT", orderID); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // 6. Mark all reservations as committed
                <span class="cov0" title="0">if err := o.reservationRepo.MarkCommitted(ctx, tx, orderID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 7. Update order status to paid
                <span class="cov0" title="0">if err := o.orderRepo.Updatestatus(ctx, orderID, domain.StatusPaid); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

// CancelOrder implements domain.OrderUsecase.
func (o *orderUsecase) CancelOrder(ctx context.Context, orderID uuid.UUID) error <span class="cov0" title="0">{
        _, err := o.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov0" title="0">{
                // 1. Get order details
                order, err := o.orderRepo.GetByID(ctx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 2. Validate order can be cancelled
                <span class="cov0" title="0">if order.Status != domain.StatusAwaitingPayment &amp;&amp; order.Status != domain.StatusPending </span><span class="cov0" title="0">{
                        return nil, errors.New("order cannot be cancelled in current status")
                }</span>

                // 3. Get all pending reservations
                <span class="cov0" title="0">reservations, err := o.reservationRepo.GetByOrderID(ctx, tx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 4. Release stock for all pending reservations
                <span class="cov0" title="0">for _, reservation := range reservations </span><span class="cov0" title="0">{
                        if reservation.Status == domain.ResvPending </span><span class="cov0" title="0">{
                                // Release the reserved stock
                                if err := o.productStockRepo.ReleaseStock(ctx, tx, reservation.ProductID, reservation.WarehouseID, int32(reservation.Qty)); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // Log stock movement
                                <span class="cov0" title="0">if err := o.movementRepository.Append(ctx, tx, reservation.ProductID, reservation.WarehouseID,
                                        "RELEASE", reservation.Qty, "ORDER_CANCELLED", orderID); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                }

                // 5. Mark reservations as released
                <span class="cov0" title="0">if err := o.reservationRepo.MarkReleased(ctx, tx, orderID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // 6. Update order status to cancelled
                <span class="cov0" title="0">if err := o.orderRepo.Updatestatus(ctx, orderID, domain.StatusCancelled); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return nil, nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

// GetOrderDetails implements domain.OrderUsecase.
func (o *orderUsecase) GetOrderDetails(ctx context.Context, orderID uuid.UUID) (*domain.Order, error) <span class="cov0" title="0">{
        return o.orderRepo.GetByID(ctx, orderID)
}</span>

// GetUserOrders implements domain.OrderUsecase.
func (o *orderUsecase) GetUserOrders(ctx context.Context, userID uuid.UUID, pagination paginator.PaginationRequest) (*paginator.PaginationResult[domain.OrderListItem], error) <span class="cov8" title="1">{
        pagination.ValidateAndSetDefault()
        offset := pagination.GetOffset()

        orders, totalCount, err := o.orderRepo.GetByUserID(ctx, userID, pagination.Limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return paginator.NewPaginationResult(orders, totalCount, pagination), nil</span>
}

func NewOrderUsecase(
        db pqsql.Database,
        orderRepo domain.OrderRepository,
        idemRepo domain.IdempotencyRequestRepository,
        orderItemRepo domain.OrderItemRepository,
        reservationRepo domain.ReservationRepository,
        movementRepository domain.MovementRepository,
        productStockRepo domain.ProductStockRepository,
        pickWarehouseRepo domain.WarehouseRepository) domain.OrderUsecase <span class="cov8" title="1">{
        return &amp;orderUsecase{
                db:                 db,
                orderRepo:          orderRepo,
                idemRepo:           idemRepo,
                orderItemRepo:      orderItemRepo,
                reservationRepo:    reservationRepo,
                movementRepository: movementRepository,
                productStockRepo:   productStockRepo,
                pickWarehouseRepo:  pickWarehouseRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package usecase

import (
        "context"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/pkg/paginator"
        "github.com/google/uuid"
)

type productUsecase struct {
        productRepository      domain.ProductRepository
        productStockRepository domain.ProductStockRepository
        paginator              paginator.Paginator[domain.RetrieveProduct]
}

// RetrieveAll implements domain.ProductUsecase.
func (pu *productUsecase) RetrieveAll(ctx context.Context, pagination paginator.PaginationRequest) (*paginator.PaginationResult[domain.RetrieveProduct], error) <span class="cov8" title="1">{
        return pu.paginator.Paginate(ctx, pagination, func(ctx context.Context, offset, limit int) (items []domain.RetrieveProduct, totalItems int, err error) </span><span class="cov8" title="1">{
                items, err = pu.productRepository.RetrieveAll(ctx, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return items, totalItems, err
                }</span>

                <span class="cov8" title="1">totalItems = len(items)
                return items, totalItems, nil</span>
        })
}

func (pu *productUsecase) Create(ctx context.Context, payload domain.CreateProductRequest) error <span class="cov8" title="1">{
        warehouseId, err := uuid.Parse(payload.WarehouseID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">product := domain.Product{
                SKU:  payload.SKU,
                Name: payload.Name,
        }

        productId, err := pu.productRepository.Create(ctx, &amp;product)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">productStock := domain.ProductStock{
                WarehouseID: warehouseId,
                ProductID:   productId,
                OnHand:      payload.OnHand,
        }

        if _, err = pu.productStockRepository.Create(ctx, &amp;productStock); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewProductUsecase(
        productRepository domain.ProductRepository,
        productStockUsecase domain.ProductStockRepository,
) domain.ProductUsecase <span class="cov8" title="1">{
        return &amp;productUsecase{
                productRepository:      productRepository,
                productStockRepository: productStockUsecase,
                paginator:              paginator.NewOffsetPaginator[domain.RetrieveProduct](),
        }
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package usecase

import (
        "context"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
)

type shopUsecase struct {
        shopRepository domain.ShopRepository
}

// Create implements domain.ShopUsecase.
func (s *shopUsecase) Create(ctx context.Context, payload domain.CreateShopRequest) error <span class="cov8" title="1">{
        shop := &amp;domain.Shop{
                Name: payload.Name,
        }

        if _, err := s.shopRepository.Create(ctx, shop); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete implements domain.ShopUsecase.
func (s *shopUsecase) Delete(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        if err := s.shopRepository.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Retrieve implements domain.ShopUsecase.
func (s *shopUsecase) Retrieve(ctx context.Context, id uuid.UUID) (*domain.Shop, error) <span class="cov8" title="1">{
        shop, err := s.shopRepository.Retrieve(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return shop, nil</span>
}

// Update implements domain.ShopUsecase.
func (s *shopUsecase) Update(ctx context.Context, payload domain.UpdateShopRequest) error <span class="cov8" title="1">{
        shop := &amp;domain.Shop{
                ID:   payload.ID,
                Name: payload.Name,
        }

        if err := s.shopRepository.Update(ctx, shop); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewShopUsecase(shopRepository domain.ShopRepository) domain.ShopUsecase <span class="cov8" title="1">{
        return &amp;shopUsecase{
                shopRepository: shopRepository,
        }
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package usecase

import (
        "context"
        "database/sql"
        "log"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
)

type StockReleaseUsecase interface {
        ProcessExpiredReservations(ctx context.Context, batchSize int) error
        ReleaseReservationStock(ctx context.Context, reservation domain.Reservation) error
}

type stockReleaseUsecase struct {
        db               pqsql.Database
        reservationRepo  domain.ReservationRepository
        productStockRepo domain.ProductStockRepository
        movementRepo     domain.MovementRepository
        orderRepo        domain.OrderRepository
}

// ProcessExpiredReservations implements StockReleaseUsecase.
func (s *stockReleaseUsecase) ProcessExpiredReservations(ctx context.Context, batchSize int) error <span class="cov8" title="1">{
        _, err := s.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov8" title="1">{
                // Pick expired reservations for update
                expiredReservations, err := s.reservationRepo.PickExpiredForUpdate(ctx, tx, batchSize)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">log.Printf("Found %d expired reservations to process", len(expiredReservations))

                for _, reservation := range expiredReservations </span><span class="cov8" title="1">{
                        // Release stock for each expired reservation
                        if err := s.releaseStockForReservation(ctx, tx, reservation); err != nil </span><span class="cov8" title="1">{
                                log.Printf("Error releasing stock for reservation %s: %v", reservation.ID, err)
                                return nil, err
                        }</span>

                        // Mark reservation as expired
                        <span class="cov8" title="1">if err := s.reservationRepo.MarkExpired(ctx, tx, reservation.ID); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error marking reservation %s as expired: %v", reservation.ID, err)
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">log.Printf("Successfully released stock and marked reservation %s as expired", reservation.ID)</span>
                }

                // Check if all reservations for orders are expired and update order status
                <span class="cov8" title="1">if err := s.updateOrderStatusIfAllReservationsExpired(ctx, tx, expiredReservations); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return err</span>
}

// ReleaseReservationStock implements StockReleaseUsecase.
func (s *stockReleaseUsecase) ReleaseReservationStock(ctx context.Context, reservation domain.Reservation) error <span class="cov8" title="1">{
        _, err := s.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov8" title="1">{
                return nil, s.releaseStockForReservation(ctx, tx, reservation)
        }</span>)
        <span class="cov8" title="1">return err</span>
}

func (s *stockReleaseUsecase) releaseStockForReservation(ctx context.Context, tx *sql.Tx, reservation domain.Reservation) error <span class="cov8" title="1">{
        // Release the reserved stock
        if err := s.productStockRepo.ReleaseStock(ctx, tx, reservation.ProductID, reservation.WarehouseID, int32(reservation.Qty)); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Record stock movement for audit trail
        <span class="cov8" title="1">if err := s.movementRepo.Append(ctx, tx, reservation.ProductID, reservation.WarehouseID,
                "RELEASE", reservation.Qty, "RESERVATION_EXPIRED", reservation.ID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *stockReleaseUsecase) updateOrderStatusIfAllReservationsExpired(ctx context.Context, tx *sql.Tx, expiredReservations []domain.Reservation) error <span class="cov8" title="1">{
        orderIDs := make(map[string]bool)

        // Collect unique order IDs
        for _, reservation := range expiredReservations </span><span class="cov8" title="1">{
                orderIDs[reservation.OrderID.String()] = true
        }</span>

        // Check each order to see if all reservations are expired
        <span class="cov8" title="1">for orderIDStr := range orderIDs </span><span class="cov8" title="1">{
                orderID := expiredReservations[0].OrderID // Get the actual UUID
                for _, res := range expiredReservations </span><span class="cov8" title="1">{
                        if res.OrderID.String() == orderIDStr </span><span class="cov8" title="1">{
                                orderID = res.OrderID
                                break</span>
                        }
                }

                // Count pending reservations for this order
                <span class="cov8" title="1">pendingCount, err := s.reservationRepo.PendingCountByOrder(ctx, tx, orderID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If no pending reservations left, mark order as expired
                <span class="cov8" title="1">if pendingCount == 0 </span><span class="cov8" title="1">{
                        if err := s.orderRepo.Updatestatus(ctx, orderID, domain.StatusExpired); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">log.Printf("Order %s marked as expired - all reservations have expired", orderID)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func NewStockReleaseUsecase(
        db pqsql.Database,
        reservationRepo domain.ReservationRepository,
        productStockRepo domain.ProductStockRepository,
        movementRepo domain.MovementRepository,
        orderRepo domain.OrderRepository,
) StockReleaseUsecase <span class="cov8" title="1">{
        return &amp;stockReleaseUsecase{
                db:               db,
                reservationRepo:  reservationRepo,
                productStockRepo: productStockRepo,
                movementRepo:     movementRepo,
                orderRepo:        orderRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package usecase

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/dyaksa/warehouse/domain"
        "github.com/dyaksa/warehouse/infrastructure/pqsql"
        "github.com/google/uuid"
)

type warehouseTransferUsecase struct {
        db               pqsql.Database
        transferRepo     domain.WarehouseTransferRepository
        warehouseRepo    domain.WarehouseRepository
        productStockRepo domain.ProductStockRepository
        movementRepo     domain.MovementRepository
}

// CreateTransfer implements domain.WarehouseTransferUsecase.
func (wtu *warehouseTransferUsecase) CreateTransfer(ctx context.Context, req domain.CreateTransferRequest) (*domain.WarehouseTransfer, error) <span class="cov8" title="1">{
        fromWarehouseID, err := uuid.Parse(req.FromWarehouseID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid from_warehouse_id: %w", err)
        }</span>

        <span class="cov8" title="1">toWarehouseID, err := uuid.Parse(req.ToWarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid to_warehouse_id: %w", err)
        }</span>

        <span class="cov8" title="1">if fromWarehouseID == toWarehouseID </span><span class="cov8" title="1">{
                return nil, errors.New("cannot transfer to the same warehouse")
        }</span>

        // Validate warehouses exist and are active
        <span class="cov8" title="1">fromWarehouse, err := wtu.warehouseRepo.Retrieve(ctx, fromWarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("from warehouse not found: %w", err)
        }</span>
        <span class="cov8" title="1">if !fromWarehouse.IsActive </span><span class="cov8" title="1">{
                return nil, errors.New("source warehouse is not active")
        }</span>

        <span class="cov8" title="1">toWarehouse, err := wtu.warehouseRepo.Retrieve(ctx, toWarehouseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("to warehouse not found: %w", err)
        }</span>
        <span class="cov8" title="1">if !toWarehouse.IsActive </span><span class="cov8" title="1">{
                return nil, errors.New("destination warehouse is not active")
        }</span>

        // Validate warehouses belong to the same shop
        <span class="cov8" title="1">if fromWarehouse.ShopID != toWarehouse.ShopID </span><span class="cov8" title="1">{
                return nil, errors.New("warehouses must belong to the same shop")
        }</span>

        <span class="cov8" title="1">var transfer *domain.WarehouseTransfer
        _, err = wtu.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov8" title="1">{
                // Create transfer
                transfer = &amp;domain.WarehouseTransfer{
                        ID:              uuid.New(),
                        FromWarehouseID: fromWarehouseID,
                        ToWarehouseID:   toWarehouseID,
                        Status:          domain.TransferStatusRequested,
                }

                err := wtu.transferRepo.Create(ctx, tx, transfer)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Create transfer items
                <span class="cov8" title="1">var items []domain.WarehouseTransferItem
                for _, reqItem := range req.Items </span><span class="cov8" title="1">{
                        productID, err := uuid.Parse(reqItem.ProductID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid product_id: %w", err)
                        }</span>

                        <span class="cov8" title="1">item := domain.WarehouseTransferItem{
                                ID:         uuid.New(),
                                TransferID: transfer.ID,
                                ProductID:  productID,
                                Qty:        reqItem.Qty,
                        }
                        items = append(items, item)</span>
                }

                <span class="cov8" title="1">err = wtu.transferRepo.CreateItems(ctx, tx, items)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">transfer.Items = items
                return nil, nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return transfer, nil</span>
}

// UpdateTransferStatus implements domain.WarehouseTransferUsecase.
func (wtu *warehouseTransferUsecase) UpdateTransferStatus(ctx context.Context, transferID uuid.UUID, req domain.UpdateTransferStatusRequest) error <span class="cov8" title="1">{
        // Get current transfer
        transfer, err := wtu.transferRepo.GetByID(ctx, transferID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate status transition
        <span class="cov8" title="1">if !wtu.isValidStatusTransition(transfer.Status, req.Status) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid status transition from %s to %s", transfer.Status, req.Status)
        }</span>

        // Execute the transfer if status is being set to IN_TRANSIT
        <span class="cov8" title="1">if req.Status == domain.TransferStatusInTransit </span><span class="cov8" title="1">{
                err = wtu.ExecuteTransfer(ctx, transferID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span> // ExecuteTransfer updates status internally
        }

        // For other status updates, just update the status
        <span class="cov0" title="0">_, err = wtu.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov0" title="0">{
                return nil, wtu.transferRepo.UpdateStatus(ctx, tx, transferID, req.Status)
        }</span>)

        <span class="cov0" title="0">return err</span>
}

// GetTransfer implements domain.WarehouseTransferUsecase.
func (wtu *warehouseTransferUsecase) GetTransfer(ctx context.Context, transferID uuid.UUID) (*domain.WarehouseTransfer, error) <span class="cov0" title="0">{
        return wtu.transferRepo.GetByID(ctx, transferID)
}</span>

// GetTransfersByWarehouse implements domain.WarehouseTransferUsecase.
func (wtu *warehouseTransferUsecase) GetTransfersByWarehouse(ctx context.Context, warehouseID uuid.UUID, limit, offset int) ([]domain.WarehouseTransfer, int, error) <span class="cov0" title="0">{
        return wtu.transferRepo.GetByWarehouse(ctx, warehouseID, limit, offset)
}</span>

// ExecuteTransfer implements domain.WarehouseTransferUsecase.
func (wtu *warehouseTransferUsecase) ExecuteTransfer(ctx context.Context, transferID uuid.UUID) error <span class="cov8" title="1">{
        // Get transfer details
        transfer, err := wtu.transferRepo.GetByID(ctx, transferID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if transfer.Status != domain.TransferStatusRequested &amp;&amp; transfer.Status != domain.TransferStatusApproved </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot execute transfer with status %s", transfer.Status)
        }</span>

        <span class="cov8" title="1">_, err = wtu.db.Transaction(ctx, func(ctx context.Context, tx *sql.Tx) (any, error) </span><span class="cov8" title="1">{
                // Check stock availability and reserve stock from source warehouse
                for _, item := range transfer.Items </span><span class="cov8" title="1">{
                        // Try to reserve stock from source warehouse
                        success, err := wtu.productStockRepo.TryReserveStock(ctx, tx, item.ProductID, transfer.FromWarehouseID, item.Qty)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to check stock for product %s: %w", item.ProductID, err)
                        }</span>
                        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("insufficient stock for product %s in source warehouse", item.ProductID)
                        }</span>

                        // Record outbound movement from source
                        <span class="cov8" title="1">err = wtu.movementRepo.Append(ctx, tx, item.ProductID, transfer.FromWarehouseID, "OUTBOUND", int(item.Qty), "TRANSFER", transfer.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to record outbound movement: %w", err)
                        }</span>

                        // Commit the stock removal from source warehouse
                        <span class="cov8" title="1">err = wtu.productStockRepo.CommitStock(ctx, tx, item.ProductID, transfer.FromWarehouseID, item.Qty)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to commit stock from source: %w", err)
                        }</span>
                }

                // Update transfer status to IN_TRANSIT
                <span class="cov8" title="1">err = wtu.transferRepo.UpdateStatus(ctx, tx, transferID, domain.TransferStatusInTransit)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update transfer status: %w", err)
                }</span>

                // Add stock to destination warehouse and mark as completed
                <span class="cov8" title="1">for _, item := range transfer.Items </span><span class="cov8" title="1">{
                        // Record inbound movement to destination
                        err = wtu.movementRepo.Append(ctx, tx, item.ProductID, transfer.ToWarehouseID, "INBOUND", int(item.Qty), "TRANSFER", transfer.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to record inbound movement: %w", err)
                        }</span>

                        // Add stock to destination warehouse
                        <span class="cov8" title="1">err = wtu.productStockRepo.AddStock(ctx, tx, item.ProductID, transfer.ToWarehouseID, item.Qty)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to add stock to destination: %w", err)
                        }</span>
                }

                // Mark transfer as completed
                <span class="cov8" title="1">err = wtu.transferRepo.UpdateStatus(ctx, tx, transferID, domain.TransferStatusCompleted)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to mark transfer as completed: %w", err)
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return err</span>
}

// isValidStatusTransition validates if a status transition is allowed
func (wtu *warehouseTransferUsecase) isValidStatusTransition(from, to domain.TransferStatus) bool <span class="cov8" title="1">{
        switch from </span>{
        case domain.TransferStatusRequested:<span class="cov0" title="0">
                return to == domain.TransferStatusApproved || to == domain.TransferStatusCancelled</span>
        case domain.TransferStatusApproved:<span class="cov8" title="1">
                return to == domain.TransferStatusInTransit || to == domain.TransferStatusCancelled</span>
        case domain.TransferStatusInTransit:<span class="cov0" title="0">
                return to == domain.TransferStatusCompleted || to == domain.TransferStatusCancelled</span>
        case domain.TransferStatusCompleted, domain.TransferStatusCancelled:<span class="cov8" title="1">
                return false</span> // Terminal states
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func NewWarehouseTransferUsecase(
        db pqsql.Database,
        transferRepo domain.WarehouseTransferRepository,
        warehouseRepo domain.WarehouseRepository,
        productStockRepo domain.ProductStockRepository,
        movementRepo domain.MovementRepository,
) domain.WarehouseTransferUsecase <span class="cov8" title="1">{
        return &amp;warehouseTransferUsecase{
                db:               db,
                transferRepo:     transferRepo,
                warehouseRepo:    warehouseRepo,
                productStockRepo: productStockRepo,
                movementRepo:     movementRepo,
        }
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package usecase

import (
        "context"
        "errors"

        "github.com/dyaksa/warehouse/domain"
        "github.com/google/uuid"
)

type warehouseUsecase struct {
        warehouseRepo domain.WarehouseRepository
        transferRepo  domain.WarehouseTransferRepository
}

// Create implements domain.WarehouseUsecase.
func (w *warehouseUsecase) Create(ctx context.Context, payload domain.WarehouseCreateRequest) error <span class="cov8" title="1">{
        shopID, err := uuid.Parse(payload.ShopID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">warehouse := &amp;domain.WareHouse{
                ShopID:   shopID,
                Name:     payload.Name,
                IsActive: payload.IsActive,
        }

        return w.warehouseRepo.Create(ctx, warehouse)</span>
}

// Delete implements domain.WarehouseUsecase.
func (w *warehouseUsecase) Delete(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        return w.warehouseRepo.Delete(ctx, id)
}</span>

// Retrieve implements domain.WarehouseUsecase.
func (w *warehouseUsecase) Retrieve(ctx context.Context, id uuid.UUID) (*domain.WareHouseFormatter, error) <span class="cov8" title="1">{
        warehouse, err := w.warehouseRepo.Retrieve(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">wareHouseFormatter := domain.WareHouseFormatter{
                ID:        warehouse.ID,
                Name:      warehouse.Name,
                Isactive:  warehouse.IsActive,
                CreatedAt: warehouse.CreatedAt,
        }

        return &amp;wareHouseFormatter, nil</span>
}

// Update implements domain.WarehouseUsecase.
func (w *warehouseUsecase) Update(ctx context.Context, id uuid.UUID, payload domain.WarehouseCreateRequest) error <span class="cov8" title="1">{
        shopID, err := uuid.Parse(payload.ShopID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">warehouse := &amp;domain.WareHouse{
                ID:       id,
                ShopID:   shopID,
                Name:     payload.Name,
                IsActive: payload.IsActive,
        }

        return w.warehouseRepo.Update(ctx, warehouse)</span>
}

// SetActive implements domain.WarehouseUsecase.
func (w *warehouseUsecase) SetActive(ctx context.Context, id uuid.UUID, isActive bool) error <span class="cov8" title="1">{
        // If trying to deactivate, check for active transfers
        if !isActive </span><span class="cov8" title="1">{
                activeTransfers, err := w.transferRepo.GetActiveTransfersByWarehouse(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(activeTransfers) &gt; 0 </span><span class="cov8" title="1">{
                        return errors.New("cannot deactivate warehouse with active transfers")
                }</span>
        }

        <span class="cov8" title="1">return w.warehouseRepo.SetActive(ctx, id, isActive)</span>
}

// GetByShopID implements domain.WarehouseUsecase.
func (w *warehouseUsecase) GetByShopID(ctx context.Context, shopID uuid.UUID) ([]domain.WareHouseFormatter, error) <span class="cov8" title="1">{
        warehouses, err := w.warehouseRepo.GetByShopID(ctx, shopID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var formatters []domain.WareHouseFormatter
        for _, warehouse := range warehouses </span><span class="cov8" title="1">{
                formatter := domain.WareHouseFormatter{
                        ID:        warehouse.ID,
                        ShopID:    warehouse.ShopID,
                        Name:      warehouse.Name,
                        Isactive:  warehouse.IsActive,
                        CreatedAt: warehouse.CreatedAt,
                }
                formatters = append(formatters, formatter)
        }</span>

        <span class="cov8" title="1">return formatters, nil</span>
}

func NewWarehouseUsecase(warehouseRepo domain.WarehouseRepository, transferRepo domain.WarehouseTransferRepository) domain.WarehouseUsecase <span class="cov8" title="1">{
        return &amp;warehouseUsecase{
                warehouseRepo: warehouseRepo,
                transferRepo:  transferRepo,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
